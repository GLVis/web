{
    "docs": [
        {
            "location": "/", 
            "text": "GLVis is a \nlightweight\n tool for \naccurate\n and \nflexible\n finite element visualization.\n\n\nFeatures\n\n\n\n\nAccurate functional representation of many \nfinite elements\n.\n\n\nSupport for \narbitrary high-order\n and \nNURBS\n meshes.\n\n\nServer mode\n accepting multiple socket connections.\n\n\nVisualization of \nparallel\n meshes and solutions.\n\n\n... and \nmany more\n.\n\n\n\n\nGLVis is based on the \nMFEM\n library and is currently used in the \nBLAST\n, \nhypre\n and \nXBraid\n projects. See also our \nGallery\n.\n\n\n\n\n\n\nNews\n\n\n\n\n\n\n\n\nDate\n\n\nMessage\n\n\n\n\n\n\n\n\n\n\nFeb 5, 2016\n\n\nVersion 3.1 \nreleased\n.\n\n\n\n\n\n\nAug 18, 2015\n\n\nMoved to \nGitHub\n and \nglvis.org\n.\n\n\n\n\n\n\nJan 26, 2015\n\n\nVersion 3.0 released.\n\n\n\n\n\n\n\n\nLatest Release\n\n\nNew features\n\n/ \nUser documentation\n\n/ \nCode documentation\n\n/ \nSources\n\n\n\n\nDownload glvis-3.1.tgz\n\n\n\n\nFor older releases see the \ndownload\n section.\n\n\nDocumentation\n\n\nBuilding\n\n/ \nMesh formats\n\n/ \nParallel visualization\n\n/ \nVTK\n\n/ \nNURBS\n\n\nNew users should start with the \noptions and general use\n tutorial.\n\n\nWe also recommend reading the \nMFEM project\n documentation.\n\n\nContact\n\n\nUse the GitHub \nissue tracker\n\nto report \nbugs\n\nor post \nquestions\n\nor \ncomments\n.\nSee\nthe \nAbout\n page for citation information.", 
            "title": "Home"
        }, 
        {
            "location": "/#features", 
            "text": "Accurate functional representation of many  finite elements .  Support for  arbitrary high-order  and  NURBS  meshes.  Server mode  accepting multiple socket connections.  Visualization of  parallel  meshes and solutions.  ... and  many more .   GLVis is based on the  MFEM  library and is currently used in the  BLAST ,  hypre  and  XBraid  projects. See also our  Gallery .", 
            "title": "Features"
        }, 
        {
            "location": "/#news", 
            "text": "Date  Message      Feb 5, 2016  Version 3.1  released .    Aug 18, 2015  Moved to  GitHub  and  glvis.org .    Jan 26, 2015  Version 3.0 released.", 
            "title": "News"
        }, 
        {
            "location": "/#latest-release", 
            "text": "New features \n/  User documentation \n/  Code documentation \n/  Sources   Download glvis-3.1.tgz   For older releases see the  download  section.", 
            "title": "Latest Release"
        }, 
        {
            "location": "/#documentation", 
            "text": "Building \n/  Mesh formats \n/  Parallel visualization \n/  VTK \n/  NURBS  New users should start with the  options and general use  tutorial.  We also recommend reading the  MFEM project  documentation.", 
            "title": "Documentation"
        }, 
        {
            "location": "/#contact", 
            "text": "Use the GitHub  issue tracker \nto report  bugs \nor post  questions \nor  comments .\nSee the  About  page for citation information.", 
            "title": "Contact"
        }, 
        {
            "location": "/features/", 
            "text": "GLVis Features\n\n\nThe goal of GLVis is to enable research and development of general finite element discretization algorithms through accurate OpenGL visualization, and tight integration with the \nMFEM\n library.\n\n\nThough depending on MFEM for its finite element dictionary, GLVis can be used independently for parallel and serial visualization. For example, the \nhypre\n library includes scripts for displaying the numerical results from its parallel example codes through GLVis.\n\n\nAccurate Visualization\n\n\n\nGLVis uses OpenGL with interactive refinement to accurately represent curved high-order \nmeshes\n and a wide variety of finite element \ngrid functions\n defined on them. GLVis is based on the modular finite element methods library \nMFEM\n, which supports in particular:\n\n\n\n\n1D, 2D, 3D volume and surface meshes,\n\n\ntriangular, quadrilateral, tetrahedral and hexahedral meshes,\n\n\ngeneral \ncurvilinear\n and \nNURBS\n meshes,\n\n\ninput in unstructured \nVTK mesh format\n,\n\n\narbitrary high-order, scalar and vector finite element and NURBS solutions,\n\n\naccurate cutting planes and level lines/surfaces,\n\n\nvisualization of parallel meshes and solutions.\n\n\n\n\nLightweight and Convenient\n\n\n\nGLVis has a fast \nkeystroke-based\n interface and uses standard OpenGL that takes advantage of\n hardware acceleration in modern GPUs.\nIt has a number of convenient features, including:\n\n\n\n\nunlimited number of refinement and de-refinement levels,\n\n\ninteractive rotation, translation and scaling with the mouse,\n\n\nsupport for different perspectives, materials, lighting, color schemes and transparency,\n\n\nprocessor and element shrinking for better visualization of the interior of 3D meshes,\n\n\nantialiased meshes and fonts,\n\n\nscreenshots in PNG or TIFF format.\n\n\n\n\nFlexible Server and Scripting Support\n\n\n\nWhen started without any options, GLVis \nestablishes a server\n, which waits for socket connections and visualizes any received data in a separate interactive window. This enables:\n\n\n\n\nsimultaneous visualization of \nmultiple fields/meshes\n in separate GLVis windows,\n\n\npersistent\n visualization of time-evolving fields,\n\n\nlocal visualization of \nparallel\n meshes and solutions sent to the server by separate socket connections from each core of a remote parallel machine,\n\n\nsaving and displaying of \nsocket stream data\n.\n\n\n\n\nGLVis can also run a \nbatch sequence\n of commands (GLVis scripts), which enable precise control of particular visualization scenes, and can be useful for making animations.\n\n\nOpen Source\n\n\nGLVis is an open-source software, and can be freely used under the terms of the \nLGPL 2.1\n license.", 
            "title": "Features"
        }, 
        {
            "location": "/features/#glvis-features", 
            "text": "The goal of GLVis is to enable research and development of general finite element discretization algorithms through accurate OpenGL visualization, and tight integration with the  MFEM  library.  Though depending on MFEM for its finite element dictionary, GLVis can be used independently for parallel and serial visualization. For example, the  hypre  library includes scripts for displaying the numerical results from its parallel example codes through GLVis.", 
            "title": "GLVis Features"
        }, 
        {
            "location": "/features/#accurate-visualization", 
            "text": "GLVis uses OpenGL with interactive refinement to accurately represent curved high-order  meshes  and a wide variety of finite element  grid functions  defined on them. GLVis is based on the modular finite element methods library  MFEM , which supports in particular:   1D, 2D, 3D volume and surface meshes,  triangular, quadrilateral, tetrahedral and hexahedral meshes,  general  curvilinear  and  NURBS  meshes,  input in unstructured  VTK mesh format ,  arbitrary high-order, scalar and vector finite element and NURBS solutions,  accurate cutting planes and level lines/surfaces,  visualization of parallel meshes and solutions.", 
            "title": "Accurate Visualization"
        }, 
        {
            "location": "/features/#lightweight-and-convenient", 
            "text": "GLVis has a fast  keystroke-based  interface and uses standard OpenGL that takes advantage of\n hardware acceleration in modern GPUs.\nIt has a number of convenient features, including:   unlimited number of refinement and de-refinement levels,  interactive rotation, translation and scaling with the mouse,  support for different perspectives, materials, lighting, color schemes and transparency,  processor and element shrinking for better visualization of the interior of 3D meshes,  antialiased meshes and fonts,  screenshots in PNG or TIFF format.", 
            "title": "Lightweight and Convenient"
        }, 
        {
            "location": "/features/#flexible-server-and-scripting-support", 
            "text": "When started without any options, GLVis  establishes a server , which waits for socket connections and visualizes any received data in a separate interactive window. This enables:   simultaneous visualization of  multiple fields/meshes  in separate GLVis windows,  persistent  visualization of time-evolving fields,  local visualization of  parallel  meshes and solutions sent to the server by separate socket connections from each core of a remote parallel machine,  saving and displaying of  socket stream data .   GLVis can also run a  batch sequence  of commands (GLVis scripts), which enable precise control of particular visualization scenes, and can be useful for making animations.", 
            "title": "Flexible Server and Scripting Support"
        }, 
        {
            "location": "/features/#open-source", 
            "text": "GLVis is an open-source software, and can be freely used under the terms of the  LGPL 2.1  license.", 
            "title": "Open Source"
        }, 
        {
            "location": "/building/", 
            "text": "Building GLVis\n\n\nA simple tutorial how to build and run GLVis together with MFEM. For more details, see the \nINSTALL\n file.\n\n\nCompilation\n\n\nDownload MFEM and GLVis (below we assume that we are working with versions 3.0)\n\n\n\n\nhttp://mfem.org\n\n\nhttp://glvis.org\n\n\n\n\nPut everything in the same directory:\n\n\n~\n ls\nglvis-3.0.tgz   mfem-3.0.tgz\n\n\n\n\nBuild the serial version of MFEM:\n\n\n~\n tar -zxvf mfem-3.0.tgz\n~\n cd mfem-3.0\n~/mfem-3.0\n make serial -j\n\n\n\n\nBuild GLVis:\n\n\n~\n tar -zxvf glvis-3.0.tgz\n~\n cd glvis-3.0\n~/glvis-3.0\n make MFEM_DIR=../mfem-3.0 -j\n\n\n\n\nThat's it! The \nglvis\n executable can be found in the \nglvis-3.0\n directory.\n\n\nTesting and rebuilding\n\n\nTo test the build, visualize a mesh with\n\n\n~/glvis-3.0\n ./glvis -m ../mfem-3.0/data/escher.mesh\n\n\n\n\nTo start a GLVis server, open a \nnew terminal\n and start glvis without arguments\n\n\n~/glvis-3.0\n ./glvis\n\n\n\n\nTo rebuild GLVis after changes in MFEM (e.g. if MFEM has rebuild in parallel), do:\n\n\n~/glvis-3.0\n make clean\n~/glvis-3.0\n make MFEM_DIR=../mfem-3.0 -j", 
            "title": "Building GLVis"
        }, 
        {
            "location": "/building/#building-glvis", 
            "text": "A simple tutorial how to build and run GLVis together with MFEM. For more details, see the  INSTALL  file.", 
            "title": "Building GLVis"
        }, 
        {
            "location": "/building/#compilation", 
            "text": "Download MFEM and GLVis (below we assume that we are working with versions 3.0)   http://mfem.org  http://glvis.org   Put everything in the same directory:  ~  ls\nglvis-3.0.tgz   mfem-3.0.tgz  Build the serial version of MFEM:  ~  tar -zxvf mfem-3.0.tgz\n~  cd mfem-3.0\n~/mfem-3.0  make serial -j  Build GLVis:  ~  tar -zxvf glvis-3.0.tgz\n~  cd glvis-3.0\n~/glvis-3.0  make MFEM_DIR=../mfem-3.0 -j  That's it! The  glvis  executable can be found in the  glvis-3.0  directory.", 
            "title": "Compilation"
        }, 
        {
            "location": "/building/#testing-and-rebuilding", 
            "text": "To test the build, visualize a mesh with  ~/glvis-3.0  ./glvis -m ../mfem-3.0/data/escher.mesh  To start a GLVis server, open a  new terminal  and start glvis without arguments  ~/glvis-3.0  ./glvis  To rebuild GLVis after changes in MFEM (e.g. if MFEM has rebuild in parallel), do:  ~/glvis-3.0  make clean\n~/glvis-3.0  make MFEM_DIR=../mfem-3.0 -j", 
            "title": "Testing and rebuilding"
        }, 
        {
            "location": "/options-and-use/", 
            "text": "Options and Use\n\n\nQuick start\n\n\n\n\nStart a socket server: \nglvis\n\n\nView a mesh: \nglvis -m star.mesh\n\n\nView a mesh with a finite element grid function: \nglvis -m star.mesh -g sol.gf\n\n\nView mesh and solution from a run on 4 processors: \nglvis -np 4 -m mesh -g sol\n (assuming data saved in files: \nmesh.000000\n, ... , \nmesh.000003\n and \nsol.000000\n, ...  , \nsol.000003\n)\n\n\nUse \nglvis -h\n to get help on all command line options.\n\n\nSee \nREADME\n for a detail of the keystroke commands accepted in the GLVis interactive window.\n\n\n\n\nSome of the command-line options of GLVis and its general use are described in more details below:\n\n\n\n\nThe GLVis server mode\n\n\nHow to visualize meshes\n\n\nHow to visualize functions\n\n\nGLVis scripts\n\n\n\n\nOptions\n\n\nGLVis has a number of command-line options that allow it to be used in several different ways. The list of all available options is given by the output of \"\nglvis -h\n\":\n\n\n       _/_/_/  _/      _/      _/  _/\n    _/        _/      _/      _/        _/_/_/\n   _/  _/_/  _/      _/      _/  _/  _/_/\n  _/    _/  _/        _/  _/    _/      _/_/\n   _/_/_/  _/_/_/_/    _/      _/  _/_/_/\n\nStart a GLVis server:\n   glvis\nVisualize a mesh:\n   glvis -m \nmesh_file\n\nVisualize mesh and solution (grid function):\n   glvis -m \nmesh_file\n -g \ngrid_function_file\n [\ncomponent\n](-gc)\nVisualize parallel mesh and solution (grid function):\n   glvis -np \n#proc\n -m \nmesh_prefix\n [\ngrid_function_prefix\n](-g)\n\nAll Options:\n   -h, --help\n        Print this help message and exit.\n   -m \nstring\n, --mesh \nstring\n, current value: (none)\n        Mesh file to visualize.\n   -g \nstring\n, --grid-function \nstring\n, current value: (none)\n        Solution (GridFunction) file to visualize.\n   -gc \nint\n, --grid-function-component \nint\n, current value: -1\n        Select a grid function component, [0-\nnum-comp\n) or -1 for all.\n   -s \nstring\n, --scalar-solution \nstring\n, current value: (none)\n        Scalar solution (vertex values) file to visualize.\n   -v \nstring\n, --vector-solution \nstring\n, current value: (none)\n        Vector solution (vertex values) file to visualize.\n   -np \nint\n, --num-proc \nint\n, current value: 0\n        Load mesh/solution from multiple processors.\n   -d \nint\n, --pad-digits \nint\n, current value: 6\n        Number of digits used for processor ranks in file names.\n   -run \nstring\n, --run-script \nstring\n, current value: (none)\n        Run a GLVis script file.\n   -k \nstring\n, --keys \nstring\n, current value: (none)\n        Execute key shortcut commands in the GLVis window.\n   -fo, --fix-orientations, -no-fo, --dont-fix-orientations, current option: --dont-fix-orientations\n        Attempt to fix the orientations of inverted elements.\n   -a, --real-attributes, -ap, --processor-attributes, current option: --processor-attributes\n        When opening a parallel mesh, use the real mesh attributes or replace them with the processor rank.\n   -grt \nint\n, --geometry-refiner-type \nint\n, current value: 0\n        Set of points to use when refining geometry: 0 = uniform, 1 = Gauss-Lobatto.\n   -sc, --save-coloring, -no-sc, --dont-save-coloring, current option: --dont-save-coloring\n        Save the mesh coloring generated when opening only a mesh.\n   -p \nint\n, --listen-port \nint\n, current value: 19916\n        Specify the port number on which to accept connections.\n   -mac, --save-stream, -no-mac, --dont-save-stream, current option: --dont-save-stream\n        In server mode, save incomming data to a file before visualization.\n   -saved \nstring\n, --saved-stream \nstring\n, current value: (none)\n        Load a GLVis stream saved to a file.\n   -ww \nint\n, --window-width \nint\n, current value: 400\n        Set the window width.\n   -wh \nint\n, --window-height \nint\n, current value: 350\n        Set the window height.\n   -wt \nstring\n, --window-title \nstring\n, current value: (default)\n        Set the window title.\n   -fn \nstring\n, --font \nstring\n, current value: (default)\n        Set the font: \nfont-name\n[-\nfont-size\n].\n   -ms \nint\n, --multisample \nint\n, current value: 4\n        Set the multisampling mode (toggled with the 'A' key).\n   -lw \ndouble\n, --line-width \ndouble\n, current value: 1\n        Set the line width (multisampling off).\n   -mslw \ndouble\n, --multisample-line-width \ndouble\n, current value: 1.4\n        Set the line width (multisampling on).\n\n\n\n\nServer mode\n\n\nGLVis can be used as a visualization server, where it waits for data sent by socket connections from applications and visualizes each socket stream in a separate interactive window:\n\n\n\n\nTo establish the GLVis server, open a new terminal and start the GLVis application without any options:\n\n\nglvis\n\n\n\n\nBy default, the server is established on \nport 19916\n, but this can be changed with the \"\n-p\n\" option.\n\n\nOn legacy Mac machines with OS X Leopard, the server needs to be started with\n\n\nglvis -mac\n\n\n\n\nThis is due to the fact that Mac OS X returns an error when \nfork() is called without an immediate exec()\n. \nNote that this option is not necessary on newer versions of OS X.\n\n\nA side effect of the \"\n-mac\n\" option is that all socket streams will be saved in incrementally named files \"\nglvis-saved.0001\n\", \"\nglvis-saved.0002\n\", and so on. These socket files consist of a \ndata type identifier\n followed by a mesh and a finite element function. For example:\n\n\nfem2d_gf_data\n\nMFEM mesh v1.0\n\ndimension\n2\n\nelements\n1\n1 3 0 1 2 3\n\nboundary\n4\n1 1 1 0\n1 1 2 1\n1 1 3 2\n1 1 0 3\n\nvertices\n4\n\nnodes\nFiniteElementSpace\nFiniteElementCollection: Quadratic\nVDim: 2\nOrdering: 0\n\n0\n1\n1\n0.1\n0.5\n0.9\n0.5\n0\n0.45\n0\n0\n1\n0.9\n-0.05\n0.5\n1\n0.5\n0.55\n\nFiniteElementSpace\nFiniteElementCollection: Quadratic\nVDim: 1\nOrdering: 0\n\n0\n0\n0\n0\n0\n0\n0\n0\n1\n\n\n\n\nNote that the mesh portion of the above file is the MFEM mesh v1.0 version of the quad.vtk mesh from the \ncurvilinear VTK tutorial\n.\n\n\nThe \"\n*.saved\n\" files contain an \nexact copy\n of the socket data stream which can be visualized later as follows:\n\n\nglvis -saved glvis-saved.0001\n\n\n\n\nBelow is the result for the above socket data using the following GLVis keystrokes in the OpenGL window: \"\nAmttII\n\" followed by multiple refinements with \"\ni\n\" and move/zoom adjustments with the mouse.\n\n\n\n\nVisualizing meshes\n\n\nGLVis can also be employed in non-sever mode, e.g. to visualize a mesh file:\n\n\nglvis -m quad.vtk\n\n\n\n\nThe optional \"\n-k\n\" parameter specifies a set of keystrokes, which will be passed directly to the GLVis window, see, e.g., the examples in the \nmesh formats tutorial\n.\n\n\nTwo dimensional meshes are shown with elements in multiple colors, corresponding to a piece-wise constant function with different values in neighboring elements. This function can be generated and saved with the \"\n-sc\n\" option, which writes it in a file called \"\nGLVis_coloring.gf\n\".\n\n\nVisualizing functions\n\n\nThere are several ways to visualize a function on a given mesh. For example we can visualize the coloring function for the mesh \nbeam-hex.mesh\n as follows:\n\n\nglvis -m beam-hex.mesh -sc\nglvis -m beam-hex.mesh -g GLVis_coloring.gf\n\n\n\n\nThe result is:\n\n\n\n\nAs another example, consider the finite element grid function \"\nquad.gf\n\" embedded in the socket stream \"\nglvis-saved.0001\n\" discussed above:\n\n\nFiniteElementSpace\nFiniteElementCollection: Quadratic\nVDim: 1\nOrdering: 0\n\n0\n0\n0\n0\n0\n0\n0\n0\n1\n\n\n\n\nThen\n\n\nglvis -m quad.vtk -g quad.gf\n\n\n\n\nwill produce identical result to \"\nglvis -saved glvis-saved.0001\n\".\n\n\nVector-valued grid functions are also supported. For example, consider the following data saved in a file named \"\nquad-vec.gf\n\"\n\n\nFiniteElementSpace\nFiniteElementCollection: Quadratic\nVDim: 2\nOrdering: 0\n\n0\n0\n0\n-0.1\n0\n0.1\n0\n0\n0.05\n\n0\n0\n0\n0.1\n0.05\n0\n0\n0\n-0.05\n\n\n\n\nwhich corresponds to the Q2 vector field transforming the \"\nquad.vtk\n\" quadrilateral into the unit square:\n\n\n\n\nThe above plot was produced with:\n\n\nglvis -m quad.vtk -g quad-vec.gf -k \nfRjlAmeIIiiiiiiiiiiibbvuuuuuuuuuuu\n\n\n\n\n\nThe transformation between the two domains can be further explored with the \"\nb\n\" and \"\nn\n\" keys.\n\n\nOne can also visualize the different components of a vector field as scalar functions using the \"\n-gc\n\" option, e.g.\n\n\nglvis -m quad.vtk -g quad-vec.gf -gc 1\n\n\n\n\ngives after some manipulations the following plot:\n\n\n\n\nFinally, GLVis supports the visualization of functions with values provided only in the vertices of the mesh. \nThis is only supported for non-curved meshes!\n The scalar and vector case are handled by the \"\n-s\n\" and \"\n-v\n\" options respectively. Here is an example with the \nbeam-quad.mesh\n mesh file and a solution saved in a file \"\nbeam-quad.sol\n\":\n\n\nsolution\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n\nglvis -m beam-quad.mesh -s beam-quad.sol -k \nAmaa\n\n\n\n\n\n\n\nNote that the data in this type of solution files starts from the second line (the first line contains an identifier). The vector format for the \"\n-v\n\" option is similar, with all the x-components of the field listed first, followed by all the y-components, etc.\n\n\nGLVis scripts\n\n\nGLVis can also run a batch sequence of commands, called GLVis scripts, which are useful for saving particular visualization scenes, as well as to generate still frames for animations.\n\n\nScripts are executed with \nglvis -run\n. For example, consider the following script, saved in a file \"\nquad-vec.glvs\n\":\n\n\n# Visualization window geometry\nwindow 0 0 300 300\n\n# Initial solution\nsolution quad.vtk quad-vec.gf\n\n# Setup the GLVis scene. Executed after pressing the space bar.\n{\n   perspective off\n   view 0 0\n   viewcenter 0 0\n   zoom 1.95\n   keys fAmeIIiiiiiiiiiiibbvuuuuuuuuuuu\n}\n\n# Take multiple screenshots. Executed after pressing the space bar.\n{\n   keys b\n   solution quad.vtk quad-vec.gf screenshot quad-vec.00.png\n   keys b\n   solution quad.vtk quad-vec.gf screenshot quad-vec.01.png\n   keys b\n   solution quad.vtk quad-vec.gf screenshot quad-vec.02.png\n   keys b\n   solution quad.vtk quad-vec.gf screenshot quad-vec.03.png\n   keys b\n   solution quad.vtk quad-vec.gf screenshot quad-vec.04.png\n   keys b\n   solution quad.vtk quad-vec.gf screenshot quad-vec.05.png\n   keys b\n   solution quad.vtk quad-vec.gf screenshot quad-vec.06.png\n   keys b\n   solution quad.vtk quad-vec.gf screenshot quad-vec.07.png\n   keys b\n   solution quad.vtk quad-vec.gf screenshot quad-vec.08.png\n   keys b\n   solution quad.vtk quad-vec.gf screenshot quad-vec.09.png\n   keys b\n   solution quad.vtk quad-vec.gf screenshot quad-vec.10.png\n}\n\n\n\n\nThe \"\n#\n\" lines above indicate comments, while the braces separate the different sequences of commands that are executed together. GLVis will pause between these execution blocks, waiting for the user to press the space bar in order to continue. The \"\nsolution\n\" command above updates the mesh and the finite element function plotted, without changing any other visualization parameters, while \"\nscreenshot\n\" uses \nxwd\n or the \nTIFF library\n together with \nImageMagick's convert utility\n to save a picture in the specified format. There are a number of additional script commands available, the complete list of which can be found (and extended) by examining the \nglvis.cpp source code\n.\n\n\nExecuting\n\n\nglvis -run quad-vec.glvs\n\n\n\n\nand pressing the space bar twice in the GLVis window generates a sequence of screenshots, which can be animated, e.g., with\n\n\nconvert -delay 20 quad-vec.??.png quad-vec.gif\n\n\n\n\nThe generated animated GIF file is shown below (you may need to reload the page to see the animation):\n\n\n\n\nMore examples of animations produced with GLVis scripts can be found at the \nBLAST website\n, e.g., \nhere\n and \nhere\n.", 
            "title": "Options and Use"
        }, 
        {
            "location": "/options-and-use/#options-and-use", 
            "text": "", 
            "title": "Options and Use"
        }, 
        {
            "location": "/options-and-use/#quick-start", 
            "text": "Start a socket server:  glvis  View a mesh:  glvis -m star.mesh  View a mesh with a finite element grid function:  glvis -m star.mesh -g sol.gf  View mesh and solution from a run on 4 processors:  glvis -np 4 -m mesh -g sol  (assuming data saved in files:  mesh.000000 , ... ,  mesh.000003  and  sol.000000 , ...  ,  sol.000003 )  Use  glvis -h  to get help on all command line options.  See  README  for a detail of the keystroke commands accepted in the GLVis interactive window.   Some of the command-line options of GLVis and its general use are described in more details below:   The GLVis server mode  How to visualize meshes  How to visualize functions  GLVis scripts", 
            "title": "Quick start"
        }, 
        {
            "location": "/options-and-use/#options", 
            "text": "GLVis has a number of command-line options that allow it to be used in several different ways. The list of all available options is given by the output of \" glvis -h \":         _/_/_/  _/      _/      _/  _/\n    _/        _/      _/      _/        _/_/_/\n   _/  _/_/  _/      _/      _/  _/  _/_/\n  _/    _/  _/        _/  _/    _/      _/_/\n   _/_/_/  _/_/_/_/    _/      _/  _/_/_/\n\nStart a GLVis server:\n   glvis\nVisualize a mesh:\n   glvis -m  mesh_file \nVisualize mesh and solution (grid function):\n   glvis -m  mesh_file  -g  grid_function_file  [ component ](-gc)\nVisualize parallel mesh and solution (grid function):\n   glvis -np  #proc  -m  mesh_prefix  [ grid_function_prefix ](-g)\n\nAll Options:\n   -h, --help\n        Print this help message and exit.\n   -m  string , --mesh  string , current value: (none)\n        Mesh file to visualize.\n   -g  string , --grid-function  string , current value: (none)\n        Solution (GridFunction) file to visualize.\n   -gc  int , --grid-function-component  int , current value: -1\n        Select a grid function component, [0- num-comp ) or -1 for all.\n   -s  string , --scalar-solution  string , current value: (none)\n        Scalar solution (vertex values) file to visualize.\n   -v  string , --vector-solution  string , current value: (none)\n        Vector solution (vertex values) file to visualize.\n   -np  int , --num-proc  int , current value: 0\n        Load mesh/solution from multiple processors.\n   -d  int , --pad-digits  int , current value: 6\n        Number of digits used for processor ranks in file names.\n   -run  string , --run-script  string , current value: (none)\n        Run a GLVis script file.\n   -k  string , --keys  string , current value: (none)\n        Execute key shortcut commands in the GLVis window.\n   -fo, --fix-orientations, -no-fo, --dont-fix-orientations, current option: --dont-fix-orientations\n        Attempt to fix the orientations of inverted elements.\n   -a, --real-attributes, -ap, --processor-attributes, current option: --processor-attributes\n        When opening a parallel mesh, use the real mesh attributes or replace them with the processor rank.\n   -grt  int , --geometry-refiner-type  int , current value: 0\n        Set of points to use when refining geometry: 0 = uniform, 1 = Gauss-Lobatto.\n   -sc, --save-coloring, -no-sc, --dont-save-coloring, current option: --dont-save-coloring\n        Save the mesh coloring generated when opening only a mesh.\n   -p  int , --listen-port  int , current value: 19916\n        Specify the port number on which to accept connections.\n   -mac, --save-stream, -no-mac, --dont-save-stream, current option: --dont-save-stream\n        In server mode, save incomming data to a file before visualization.\n   -saved  string , --saved-stream  string , current value: (none)\n        Load a GLVis stream saved to a file.\n   -ww  int , --window-width  int , current value: 400\n        Set the window width.\n   -wh  int , --window-height  int , current value: 350\n        Set the window height.\n   -wt  string , --window-title  string , current value: (default)\n        Set the window title.\n   -fn  string , --font  string , current value: (default)\n        Set the font:  font-name [- font-size ].\n   -ms  int , --multisample  int , current value: 4\n        Set the multisampling mode (toggled with the 'A' key).\n   -lw  double , --line-width  double , current value: 1\n        Set the line width (multisampling off).\n   -mslw  double , --multisample-line-width  double , current value: 1.4\n        Set the line width (multisampling on).", 
            "title": "Options"
        }, 
        {
            "location": "/options-and-use/#server-mode", 
            "text": "GLVis can be used as a visualization server, where it waits for data sent by socket connections from applications and visualizes each socket stream in a separate interactive window:   To establish the GLVis server, open a new terminal and start the GLVis application without any options:  glvis  By default, the server is established on  port 19916 , but this can be changed with the \" -p \" option.  On legacy Mac machines with OS X Leopard, the server needs to be started with  glvis -mac  This is due to the fact that Mac OS X returns an error when  fork() is called without an immediate exec() .  Note that this option is not necessary on newer versions of OS X.  A side effect of the \" -mac \" option is that all socket streams will be saved in incrementally named files \" glvis-saved.0001 \", \" glvis-saved.0002 \", and so on. These socket files consist of a  data type identifier  followed by a mesh and a finite element function. For example:  fem2d_gf_data\n\nMFEM mesh v1.0\n\ndimension\n2\n\nelements\n1\n1 3 0 1 2 3\n\nboundary\n4\n1 1 1 0\n1 1 2 1\n1 1 3 2\n1 1 0 3\n\nvertices\n4\n\nnodes\nFiniteElementSpace\nFiniteElementCollection: Quadratic\nVDim: 2\nOrdering: 0\n\n0\n1\n1\n0.1\n0.5\n0.9\n0.5\n0\n0.45\n0\n0\n1\n0.9\n-0.05\n0.5\n1\n0.5\n0.55\n\nFiniteElementSpace\nFiniteElementCollection: Quadratic\nVDim: 1\nOrdering: 0\n\n0\n0\n0\n0\n0\n0\n0\n0\n1  Note that the mesh portion of the above file is the MFEM mesh v1.0 version of the quad.vtk mesh from the  curvilinear VTK tutorial .  The \" *.saved \" files contain an  exact copy  of the socket data stream which can be visualized later as follows:  glvis -saved glvis-saved.0001  Below is the result for the above socket data using the following GLVis keystrokes in the OpenGL window: \" AmttII \" followed by multiple refinements with \" i \" and move/zoom adjustments with the mouse.", 
            "title": "Server mode"
        }, 
        {
            "location": "/options-and-use/#visualizing-meshes", 
            "text": "GLVis can also be employed in non-sever mode, e.g. to visualize a mesh file:  glvis -m quad.vtk  The optional \" -k \" parameter specifies a set of keystrokes, which will be passed directly to the GLVis window, see, e.g., the examples in the  mesh formats tutorial .  Two dimensional meshes are shown with elements in multiple colors, corresponding to a piece-wise constant function with different values in neighboring elements. This function can be generated and saved with the \" -sc \" option, which writes it in a file called \" GLVis_coloring.gf \".", 
            "title": "Visualizing meshes"
        }, 
        {
            "location": "/options-and-use/#visualizing-functions", 
            "text": "There are several ways to visualize a function on a given mesh. For example we can visualize the coloring function for the mesh  beam-hex.mesh  as follows:  glvis -m beam-hex.mesh -sc\nglvis -m beam-hex.mesh -g GLVis_coloring.gf  The result is:   As another example, consider the finite element grid function \" quad.gf \" embedded in the socket stream \" glvis-saved.0001 \" discussed above:  FiniteElementSpace\nFiniteElementCollection: Quadratic\nVDim: 1\nOrdering: 0\n\n0\n0\n0\n0\n0\n0\n0\n0\n1  Then  glvis -m quad.vtk -g quad.gf  will produce identical result to \" glvis -saved glvis-saved.0001 \".  Vector-valued grid functions are also supported. For example, consider the following data saved in a file named \" quad-vec.gf \"  FiniteElementSpace\nFiniteElementCollection: Quadratic\nVDim: 2\nOrdering: 0\n\n0\n0\n0\n-0.1\n0\n0.1\n0\n0\n0.05\n\n0\n0\n0\n0.1\n0.05\n0\n0\n0\n-0.05  which corresponds to the Q2 vector field transforming the \" quad.vtk \" quadrilateral into the unit square:   The above plot was produced with:  glvis -m quad.vtk -g quad-vec.gf -k  fRjlAmeIIiiiiiiiiiiibbvuuuuuuuuuuu   The transformation between the two domains can be further explored with the \" b \" and \" n \" keys.  One can also visualize the different components of a vector field as scalar functions using the \" -gc \" option, e.g.  glvis -m quad.vtk -g quad-vec.gf -gc 1  gives after some manipulations the following plot:   Finally, GLVis supports the visualization of functions with values provided only in the vertices of the mesh.  This is only supported for non-curved meshes!  The scalar and vector case are handled by the \" -s \" and \" -v \" options respectively. Here is an example with the  beam-quad.mesh  mesh file and a solution saved in a file \" beam-quad.sol \":  solution\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18  glvis -m beam-quad.mesh -s beam-quad.sol -k  Amaa    Note that the data in this type of solution files starts from the second line (the first line contains an identifier). The vector format for the \" -v \" option is similar, with all the x-components of the field listed first, followed by all the y-components, etc.", 
            "title": "Visualizing functions"
        }, 
        {
            "location": "/options-and-use/#glvis-scripts", 
            "text": "GLVis can also run a batch sequence of commands, called GLVis scripts, which are useful for saving particular visualization scenes, as well as to generate still frames for animations.  Scripts are executed with  glvis -run . For example, consider the following script, saved in a file \" quad-vec.glvs \":  # Visualization window geometry\nwindow 0 0 300 300\n\n# Initial solution\nsolution quad.vtk quad-vec.gf\n\n# Setup the GLVis scene. Executed after pressing the space bar.\n{\n   perspective off\n   view 0 0\n   viewcenter 0 0\n   zoom 1.95\n   keys fAmeIIiiiiiiiiiiibbvuuuuuuuuuuu\n}\n\n# Take multiple screenshots. Executed after pressing the space bar.\n{\n   keys b\n   solution quad.vtk quad-vec.gf screenshot quad-vec.00.png\n   keys b\n   solution quad.vtk quad-vec.gf screenshot quad-vec.01.png\n   keys b\n   solution quad.vtk quad-vec.gf screenshot quad-vec.02.png\n   keys b\n   solution quad.vtk quad-vec.gf screenshot quad-vec.03.png\n   keys b\n   solution quad.vtk quad-vec.gf screenshot quad-vec.04.png\n   keys b\n   solution quad.vtk quad-vec.gf screenshot quad-vec.05.png\n   keys b\n   solution quad.vtk quad-vec.gf screenshot quad-vec.06.png\n   keys b\n   solution quad.vtk quad-vec.gf screenshot quad-vec.07.png\n   keys b\n   solution quad.vtk quad-vec.gf screenshot quad-vec.08.png\n   keys b\n   solution quad.vtk quad-vec.gf screenshot quad-vec.09.png\n   keys b\n   solution quad.vtk quad-vec.gf screenshot quad-vec.10.png\n}  The \" # \" lines above indicate comments, while the braces separate the different sequences of commands that are executed together. GLVis will pause between these execution blocks, waiting for the user to press the space bar in order to continue. The \" solution \" command above updates the mesh and the finite element function plotted, without changing any other visualization parameters, while \" screenshot \" uses  xwd  or the  TIFF library  together with  ImageMagick's convert utility  to save a picture in the specified format. There are a number of additional script commands available, the complete list of which can be found (and extended) by examining the  glvis.cpp source code .  Executing  glvis -run quad-vec.glvs  and pressing the space bar twice in the GLVis window generates a sequence of screenshots, which can be animated, e.g., with  convert -delay 20 quad-vec.??.png quad-vec.gif  The generated animated GIF file is shown below (you may need to reload the page to see the animation):   More examples of animations produced with GLVis scripts can be found at the  BLAST website , e.g.,  here  and  here .", 
            "title": "GLVis scripts"
        }, 
        {
            "location": "/mesh-formats/", 
            "text": "Mesh Formats\n\n\nSummary\n\n\nDescription of the various mesh formats that can be used with GLVis.\n\n\nDetails\n\n\nGLVis supports a number of mesh formats, including:\n\n\n\n\nThe \nMFEM\n mesh v1.0 format, which can describe very general meshes based on any finite element grid function supported by MFEM, including \nNURBS meshes\n.\n\n\nThe \nVTK\n unstructured mesh format, for triangular, quadrilateral, tetrahedral and hexahedral meshes. See the \ncurvilinear VTK tutorial\n for more details. Some examples of VTK meshes can be found in MFEM's \ndata directory\n.\n\n\nThe \nNETGEN\n triangular and tetrahedral mesh formats.\n\n\nThe \nTrueGrid\n hexahedral mesh format.\n\n\n\n\nMFEM mesh v1.0\n\n\nThis is the default format in GLVis. It can be used to describe simple (triangular, quadrilateral, tetrahedral and hexahedral meshes with straight edges) or complicated (curvilinear and more general) meshes.\n\n\nStraight meshes\n\n\nIn the simple case of a mesh with straight edges the format looks as follows\n\n\nMFEM mesh v1.0\n\n# Space dimension: 2 or 3\ndimension\n\ndimension\n\n\n# Mesh elements, e.g. tetrahedrons (4)\nelements\n\nnumber of elements\n\n\nelement attribute\n \ngeometry type\n \nvertex index 1\n ... \nvertex index m\n\n...\n\n# Mesh faces/edges on the boundary, e.g. triangles (2)\nboundary\n\nnumber of boundary elements\n\n\nboundary element attribute\n \ngeometry type\n \nvertex index 1\n ... \nvertex index m\n\n...\n\n# Vertex coordinates\nvertices\n\nnumber of vertices\n\n\nvdim\n\n\ncoordinate 1\n ... \ncoordinate \nvdim\n\n...\n\n\n\n\nLines starting with \"#\" denote comments. The supported geometry types are:\n\n\n\n\nPOINT       = 0\n\n\nSEGMENT     = 1\n\n\nTRIANGLE    = 2\n\n\nSQUARE      = 3\n\n\nTETRAHEDRON = 4\n\n\nCUBE        = 5\n\n\n\n\nsee the comments in \nthis source file\n for more details.\n\n\nFor example, the \nbeam-quad.mesh\n file from MFEM looks like this:\n\n\nMFEM mesh v1.0\n\ndimension\n2\n\nelements\n8\n1 3 0 1 10 9\n1 3 1 2 11 10\n1 3 2 3 12 11\n1 3 3 4 13 12\n2 3 4 5 14 13\n2 3 5 6 15 14\n2 3 6 7 16 15\n2 3 7 8 17 16\n\nboundary\n18\n3 1 1 0\n3 1 2 1\n3 1 3 2\n3 1 4 3\n3 1 5 4\n3 1 6 5\n3 1 7 6\n3 1 8 7\n3 1 9 10\n3 1 10 11\n3 1 11 12\n3 1 12 13\n3 1 13 14\n3 1 14 15\n3 1 15 16\n3 1 16 17\n1 1 0 9\n2 1 17 8\n\nvertices\n18\n2\n0 0\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0\n8 0\n0 1\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1\n\n\n\n\nwhich corresponds to the mesh\n\n\n\n\nvisualized with\n\n\nglvis -m beam-quad.mesh -k \nAme****\n\n\n\n\n\nCurvilinear and more general meshes\n\n\nThe MFEM mesh v1.0 format also support the general description of meshes based on a vector finite element grid function with degrees of freedom in the \"nodes\" of the mesh:\n\n\nMFEM mesh v1.0\n\n# Space dimension: 2 or 3\ndimension\n\ndimension\n\n\n# Mesh elements, e.g. tetrahedrons (4)\nelements\n\nnumber of elements\n\n\nelement attribute\n \ngeometry type\n \nvertex index 1\n ... \nvertex index m\n\n...\n\n# Mesh faces/edges on the boundary, e.g. triangles (2)\nboundary\n\nnumber of boundary elements\n\n\nboundary element attribute\n \ngeometry type\n \nvertex index 1\n ... \nvertex index m\n\n...\n\n# Number of vertices (no coordinates)\nvertices\n\nnumber of vertices\n\n\n# Mesh nodes as degrees of freedom of a finite element grid function\nnodes\nFiniteElementSpace\nFiniteElementCollection: \nfinite element collection\n\nVDim: \ndimension\n\nOrdering: 0\n\nx-coordinate degrees of freedom\n\n...\n\ny-coordinate degrees of freedom\n\n...\n\nz-coordinate degrees of freedom\n\n...\n\n\n\n\nSome possible \nfinite element collection\n choices are: \nLinear\n, \nQuadratic\n and \nCubic\n corresponding to curvilinear P1/Q1, P2/Q2 and P3/Q3 meshes. The algorithm for the numbering of the degrees of freedom can be found in \nMFEM's source code\n.\n\n\nFor example, the \nescher-p3.mesh\n from MFEM's \ndata directory\n describes a tetrahedral mesh with nodes given by a P3 vector Lagrangian finite element function. Visualizing this mesh with\n\n\nglvis -m escher-p3.mesh -k \nAaaoooooooooo**************tt\n\n\n\n\n\nwe get:\n\n\n\n\nNURBS meshes\n\n\nNURBS meshes and functions are fully supported in GLVis. For example,\n\n\nglvis -m pipe-nurbs.mesh\n\n\n\n\nproduces after some refinement (key \"\no\n\") and mouse manipulations\n\n\n\n\nMore details about the NURBS mesh format can be found in the separate \nNURBS tutorial\n.", 
            "title": "Mesh Formats"
        }, 
        {
            "location": "/mesh-formats/#mesh-formats", 
            "text": "", 
            "title": "Mesh Formats"
        }, 
        {
            "location": "/mesh-formats/#summary", 
            "text": "Description of the various mesh formats that can be used with GLVis.", 
            "title": "Summary"
        }, 
        {
            "location": "/mesh-formats/#details", 
            "text": "GLVis supports a number of mesh formats, including:   The  MFEM  mesh v1.0 format, which can describe very general meshes based on any finite element grid function supported by MFEM, including  NURBS meshes .  The  VTK  unstructured mesh format, for triangular, quadrilateral, tetrahedral and hexahedral meshes. See the  curvilinear VTK tutorial  for more details. Some examples of VTK meshes can be found in MFEM's  data directory .  The  NETGEN  triangular and tetrahedral mesh formats.  The  TrueGrid  hexahedral mesh format.   MFEM mesh v1.0  This is the default format in GLVis. It can be used to describe simple (triangular, quadrilateral, tetrahedral and hexahedral meshes with straight edges) or complicated (curvilinear and more general) meshes.  Straight meshes  In the simple case of a mesh with straight edges the format looks as follows  MFEM mesh v1.0\n\n# Space dimension: 2 or 3\ndimension dimension \n\n# Mesh elements, e.g. tetrahedrons (4)\nelements number of elements  element attribute   geometry type   vertex index 1  ...  vertex index m \n...\n\n# Mesh faces/edges on the boundary, e.g. triangles (2)\nboundary number of boundary elements  boundary element attribute   geometry type   vertex index 1  ...  vertex index m \n...\n\n# Vertex coordinates\nvertices number of vertices  vdim  coordinate 1  ...  coordinate  vdim \n...  Lines starting with \"#\" denote comments. The supported geometry types are:   POINT       = 0  SEGMENT     = 1  TRIANGLE    = 2  SQUARE      = 3  TETRAHEDRON = 4  CUBE        = 5   see the comments in  this source file  for more details.  For example, the  beam-quad.mesh  file from MFEM looks like this:  MFEM mesh v1.0\n\ndimension\n2\n\nelements\n8\n1 3 0 1 10 9\n1 3 1 2 11 10\n1 3 2 3 12 11\n1 3 3 4 13 12\n2 3 4 5 14 13\n2 3 5 6 15 14\n2 3 6 7 16 15\n2 3 7 8 17 16\n\nboundary\n18\n3 1 1 0\n3 1 2 1\n3 1 3 2\n3 1 4 3\n3 1 5 4\n3 1 6 5\n3 1 7 6\n3 1 8 7\n3 1 9 10\n3 1 10 11\n3 1 11 12\n3 1 12 13\n3 1 13 14\n3 1 14 15\n3 1 15 16\n3 1 16 17\n1 1 0 9\n2 1 17 8\n\nvertices\n18\n2\n0 0\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0\n8 0\n0 1\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1  which corresponds to the mesh   visualized with  glvis -m beam-quad.mesh -k  Ame****   Curvilinear and more general meshes  The MFEM mesh v1.0 format also support the general description of meshes based on a vector finite element grid function with degrees of freedom in the \"nodes\" of the mesh:  MFEM mesh v1.0\n\n# Space dimension: 2 or 3\ndimension dimension \n\n# Mesh elements, e.g. tetrahedrons (4)\nelements number of elements  element attribute   geometry type   vertex index 1  ...  vertex index m \n...\n\n# Mesh faces/edges on the boundary, e.g. triangles (2)\nboundary number of boundary elements  boundary element attribute   geometry type   vertex index 1  ...  vertex index m \n...\n\n# Number of vertices (no coordinates)\nvertices number of vertices \n\n# Mesh nodes as degrees of freedom of a finite element grid function\nnodes\nFiniteElementSpace\nFiniteElementCollection:  finite element collection \nVDim:  dimension \nOrdering: 0 x-coordinate degrees of freedom \n... y-coordinate degrees of freedom \n... z-coordinate degrees of freedom \n...  Some possible  finite element collection  choices are:  Linear ,  Quadratic  and  Cubic  corresponding to curvilinear P1/Q1, P2/Q2 and P3/Q3 meshes. The algorithm for the numbering of the degrees of freedom can be found in  MFEM's source code .  For example, the  escher-p3.mesh  from MFEM's  data directory  describes a tetrahedral mesh with nodes given by a P3 vector Lagrangian finite element function. Visualizing this mesh with  glvis -m escher-p3.mesh -k  Aaaoooooooooo**************tt   we get:   NURBS meshes  NURBS meshes and functions are fully supported in GLVis. For example,  glvis -m pipe-nurbs.mesh  produces after some refinement (key \" o \") and mouse manipulations   More details about the NURBS mesh format can be found in the separate  NURBS tutorial .", 
            "title": "Details"
        }, 
        {
            "location": "/parallel-visualization/", 
            "text": "Parallel Visualization\n\n\nSummary\n\n\nDescription of the parallel visualization capabilities of GLVis.\n\n\nDetails\n\n\nGLVis supports visualization of parallel meshes and grid functions, which are either saved in separate files or send through separate socket connections from each processor. In both cases, GLVis will stitch the parallel results to show the global mesh and solution, but the subdomain data can still be examined through the \nF3\n/\nF4\n, \nF8\n, \nF9\n/\nF10\n and \nF11\n/\nF12\n keystrokes.\n\n\nFor data saved in separate files, e.g. \nmesh.000000\n, ... , \nmesh.000003\n and \nsol.000000\n, ...  , \nsol.000003\n from a run on 4 processors, the format is:\n\n\nglvis -np 4 -m mesh -g sol\n\n\n\n\nIn other words, the actual mesh and solution file names are obtained from the above prefixes \"\nmesh\n\" and \"\nsol\n\" by appending \"\n.\n\" followed by a 6-digit processor/subdomain number padded with 0's, see e.g. \nthis example\n. (Note that the related obsolete option -par3d was removed in version 2.0).\n\n\nFor results send by separate socket connections from each processor, the\nparallel format just adds a prefix specifying the total number of processors and the current processor id:\n\n\nparallel \nnum_proc\n \nmyid\n\n\n\n\n\nAn example of this can be found \nhere\n.\n\n\nTo illustrate the parallel visualization capabilities of GLVis, suppose that we have solves a simple Poisson problem on a 2x2 square grid using 2 processors. The processor mesh files generated, e.g. by \nMFEM's Parallel Example 1\n, are \"\nmesh.000000\n\":\n\n\nMFEM mesh v1.0\n\n#\n# MFEM Geometry Types (see mesh/geom.hpp):\n#\n# POINT       = 0\n# SEGMENT     = 1\n# TRIANGLE    = 2\n# SQUARE      = 3\n# TETRAHEDRON = 4\n# CUBE        = 5\n#\n\ndimension\n2\n\nelements\n2\n1 3 5 2 0 3\n1 3 4 5 3 1\n\nboundary\n6\n1 1 0 3\n1 1 1 4\n1 1 2 0\n1 1 3 1\n2 1 5 4\n2 1 2 5\n\nvertices\n6\n2\n1 1\n0 1\n1 0.5\n0.5 1\n0 0.5\n0.5 0.5\n\n\n\n\nand \"\nmesh.000001\n\":\n\n\nMFEM mesh v1.0\n\n#\n# MFEM Geometry Types (see mesh/geom.hpp):\n#\n# POINT       = 0\n# SEGMENT     = 1\n# TRIANGLE    = 2\n# SQUARE      = 3\n# TETRAHEDRON = 4\n# CUBE        = 5\n#\n\ndimension\n2\n\nelements\n2\n1 3 0 2 5 4\n1 3 2 1 3 5\n\nboundary\n6\n1 1 0 2\n1 1 1 3\n1 1 2 1\n1 1 4 0\n3 1 5 4\n3 1 3 5\n\nvertices\n6\n2\n0 0\n1 0\n0.5 0\n1 0.5\n0 0.5\n0.5 0.5\n\n\n\n\nThe corresponding linear (Q1) finite element solutions on each processor are, \"\nsol.000000\n\":\n\n\nFiniteElementSpace\nFiniteElementCollection: Linear\nVDim: 1\nOrdering: 0\n\n0\n0\n0\n0\n0\n0.09375\n\n\n\n\nand \"\nsol.000001\n\", which happens to be identical to \"\nsol.000000\n\" in this case.\n\n\nAs before, we can view the local mesh and solution on each processor by specifying its mesh and solution files:\n\n\nglvis -m mesh.000000 -g sol.000000\n\n\n\n\n\n\nHowever, we can also view the global (stitched) mesh by specifying the number of processors, and the mesh prefix\n\n\nglvis -np 2 -m mesh\n\n\n\n\n\n\nThe global parallel mesh and solution can be visualized with\n\n\nglvis -np 2 -m mesh -g sol\n\n\n\n\n\n\nand now we can use, e.g. the \nF11\n/\nF12\n keystrokes to shrink/zoom the subdomains corresponding to different processors. Here is what the result looks like for a refined version of this problem on 16 processors:\n\n\n\n\nParallel meshes and solutions are also supported in  GLVis scripts. The corresponding command is\n\n\npsolution \nnum_proc\n \nmesh_prefix\n \nattr_flag\n \nsolution_prefix\n\n\n\n\n\nwhere \"\nattr_flag\n\" controls if the boundary attributes should be replaced with the processor number or if they should be kept unchanged. This option is also available from the command line as \"'-a'\".", 
            "title": "Parallel Visualization"
        }, 
        {
            "location": "/parallel-visualization/#parallel-visualization", 
            "text": "", 
            "title": "Parallel Visualization"
        }, 
        {
            "location": "/parallel-visualization/#summary", 
            "text": "Description of the parallel visualization capabilities of GLVis.", 
            "title": "Summary"
        }, 
        {
            "location": "/parallel-visualization/#details", 
            "text": "GLVis supports visualization of parallel meshes and grid functions, which are either saved in separate files or send through separate socket connections from each processor. In both cases, GLVis will stitch the parallel results to show the global mesh and solution, but the subdomain data can still be examined through the  F3 / F4 ,  F8 ,  F9 / F10  and  F11 / F12  keystrokes.  For data saved in separate files, e.g.  mesh.000000 , ... ,  mesh.000003  and  sol.000000 , ...  ,  sol.000003  from a run on 4 processors, the format is:  glvis -np 4 -m mesh -g sol  In other words, the actual mesh and solution file names are obtained from the above prefixes \" mesh \" and \" sol \" by appending \" . \" followed by a 6-digit processor/subdomain number padded with 0's, see e.g.  this example . (Note that the related obsolete option -par3d was removed in version 2.0).  For results send by separate socket connections from each processor, the\nparallel format just adds a prefix specifying the total number of processors and the current processor id:  parallel  num_proc   myid   An example of this can be found  here .  To illustrate the parallel visualization capabilities of GLVis, suppose that we have solves a simple Poisson problem on a 2x2 square grid using 2 processors. The processor mesh files generated, e.g. by  MFEM's Parallel Example 1 , are \" mesh.000000 \":  MFEM mesh v1.0\n\n#\n# MFEM Geometry Types (see mesh/geom.hpp):\n#\n# POINT       = 0\n# SEGMENT     = 1\n# TRIANGLE    = 2\n# SQUARE      = 3\n# TETRAHEDRON = 4\n# CUBE        = 5\n#\n\ndimension\n2\n\nelements\n2\n1 3 5 2 0 3\n1 3 4 5 3 1\n\nboundary\n6\n1 1 0 3\n1 1 1 4\n1 1 2 0\n1 1 3 1\n2 1 5 4\n2 1 2 5\n\nvertices\n6\n2\n1 1\n0 1\n1 0.5\n0.5 1\n0 0.5\n0.5 0.5  and \" mesh.000001 \":  MFEM mesh v1.0\n\n#\n# MFEM Geometry Types (see mesh/geom.hpp):\n#\n# POINT       = 0\n# SEGMENT     = 1\n# TRIANGLE    = 2\n# SQUARE      = 3\n# TETRAHEDRON = 4\n# CUBE        = 5\n#\n\ndimension\n2\n\nelements\n2\n1 3 0 2 5 4\n1 3 2 1 3 5\n\nboundary\n6\n1 1 0 2\n1 1 1 3\n1 1 2 1\n1 1 4 0\n3 1 5 4\n3 1 3 5\n\nvertices\n6\n2\n0 0\n1 0\n0.5 0\n1 0.5\n0 0.5\n0.5 0.5  The corresponding linear (Q1) finite element solutions on each processor are, \" sol.000000 \":  FiniteElementSpace\nFiniteElementCollection: Linear\nVDim: 1\nOrdering: 0\n\n0\n0\n0\n0\n0\n0.09375  and \" sol.000001 \", which happens to be identical to \" sol.000000 \" in this case.  As before, we can view the local mesh and solution on each processor by specifying its mesh and solution files:  glvis -m mesh.000000 -g sol.000000   However, we can also view the global (stitched) mesh by specifying the number of processors, and the mesh prefix  glvis -np 2 -m mesh   The global parallel mesh and solution can be visualized with  glvis -np 2 -m mesh -g sol   and now we can use, e.g. the  F11 / F12  keystrokes to shrink/zoom the subdomains corresponding to different processors. Here is what the result looks like for a refined version of this problem on 16 processors:   Parallel meshes and solutions are also supported in  GLVis scripts. The corresponding command is  psolution  num_proc   mesh_prefix   attr_flag   solution_prefix   where \" attr_flag \" controls if the boundary attributes should be replaced with the processor number or if they should be kept unchanged. This option is also available from the command line as \"'-a'\".", 
            "title": "Details"
        }, 
        {
            "location": "/curvilinear-vtk-meshes/", 
            "text": "Curvilinear VTK Meshes\n\n\nSummary\n\n\nA simple tutorial how to visualize curvilinear meshes in VTK format with GLVis.\n\n\nDetails\n\n\nGLVis supports quadratic triangular, quadrilaterals, tetrahedral and hexahedral curvilinear meshes in VTK format. This format is described in the \nVTK file format documentation\n. The local numbering of degrees of freedom for the biquadratic quads and triquadratic hexes can be found in the Doxygen reference of the \nvtkBiQuadraticQuad\n and \nvtkTriQuadraticHexahedron\n classes. Currently VTK does not support cubic, and higher-order meshes.\n\n\nAs an example, consider a simple curved quadrilateral saved in a file \nquad.vtk\n:\n\n\n# vtk DataFile Version 3.0\nGenerated by MFEM\nASCII\nDATASET UNSTRUCTURED_GRID\nPOINTS 9 double\n0 0 0\n1 0 0\n1 1 0\n0.1 0.9 0\n0.5 -0.05 0\n0.9 0.5 0\n0.5 1 0\n0 0.5 0\n0.45 0.55 0\nCELLS 1 10\n9 0 1 2 3 4 5 6 7 8\nCELL_TYPES 1\n28\nCELL_DATA 1\nSCALARS material int\nLOOKUP_TABLE default\n1\n\n\n\n\nVisualizing it with \"\nglvis -m quad.vtk\n\" and typing \"\nAemiii\n\" in the GLVis window we get:\n\n\n\n\nThe \"\ni\n\" key increases the reference element subdivision which gives an increasingly better approximation of the actual curvature of the element. To view the curvature of the mapping inside the element we can use the \"I\" key, e.g.,\n\n\nglvis -m quad.vtk -k \nAemIIiii\n\n\n\n\n\n\n\nHere is a slightly more complicated \nquadratic quadrilateral\n mesh example (the different colors in the GLVis window are used to distinguish neighboring elements):\n\n\nglvis -m star-q2.vtk -k \nAm\n\n\n\n\n\n\n\nGLVis can also handle \nquadratic triangular\n meshes:\n\n\nglvis -m square-disc-p2.vtk -k \nAm\n\n\n\n\n\n\n\nAs well as \nquadratic tetrahedral\n and \nquadratic hexahedral\n VTK meshes:\n\n\nglvis -m escher-p2.vtk -k \nAaaooooo**************\n\n\n\n\n\n\n\nglvis -m fichera-q2.vtk -k \nAaaooooo******", 
            "title": "Curvilinear VTK Meshes"
        }, 
        {
            "location": "/curvilinear-vtk-meshes/#curvilinear-vtk-meshes", 
            "text": "", 
            "title": "Curvilinear VTK Meshes"
        }, 
        {
            "location": "/curvilinear-vtk-meshes/#summary", 
            "text": "A simple tutorial how to visualize curvilinear meshes in VTK format with GLVis.", 
            "title": "Summary"
        }, 
        {
            "location": "/curvilinear-vtk-meshes/#details", 
            "text": "GLVis supports quadratic triangular, quadrilaterals, tetrahedral and hexahedral curvilinear meshes in VTK format. This format is described in the  VTK file format documentation . The local numbering of degrees of freedom for the biquadratic quads and triquadratic hexes can be found in the Doxygen reference of the  vtkBiQuadraticQuad  and  vtkTriQuadraticHexahedron  classes. Currently VTK does not support cubic, and higher-order meshes.  As an example, consider a simple curved quadrilateral saved in a file  quad.vtk :  # vtk DataFile Version 3.0\nGenerated by MFEM\nASCII\nDATASET UNSTRUCTURED_GRID\nPOINTS 9 double\n0 0 0\n1 0 0\n1 1 0\n0.1 0.9 0\n0.5 -0.05 0\n0.9 0.5 0\n0.5 1 0\n0 0.5 0\n0.45 0.55 0\nCELLS 1 10\n9 0 1 2 3 4 5 6 7 8\nCELL_TYPES 1\n28\nCELL_DATA 1\nSCALARS material int\nLOOKUP_TABLE default\n1  Visualizing it with \" glvis -m quad.vtk \" and typing \" Aemiii \" in the GLVis window we get:   The \" i \" key increases the reference element subdivision which gives an increasingly better approximation of the actual curvature of the element. To view the curvature of the mapping inside the element we can use the \"I\" key, e.g.,  glvis -m quad.vtk -k  AemIIiii    Here is a slightly more complicated  quadratic quadrilateral  mesh example (the different colors in the GLVis window are used to distinguish neighboring elements):  glvis -m star-q2.vtk -k  Am    GLVis can also handle  quadratic triangular  meshes:  glvis -m square-disc-p2.vtk -k  Am    As well as  quadratic tetrahedral  and  quadratic hexahedral  VTK meshes:  glvis -m escher-p2.vtk -k  Aaaooooo**************    glvis -m fichera-q2.vtk -k  Aaaooooo******", 
            "title": "Details"
        }, 
        {
            "location": "/nurbs/", 
            "text": "NURBS Meshes\n\n\nSummary\n\n\nA simple tutorial how to visualize NURBS meshes and solutions with GLVis.\n\n\nDetails\n\n\nGLVis provides full support for meshes and discretization spaces based on Non-uniform Rational B-Splines (NURBS). These are treated similarly to general \ncurvilinear meshes\n where the NURBS nodes are specified as a grid function at the end of the mesh file.\n\n\nFor example, here is a simple quadratic NURBS mesh for a square domain with a (perfectly) circular hole in the middle. (The exact representation of conical sections is a major advantage of the NURBS approach over high-order finite elements.)\n\n\nMFEM NURBS mesh v1.0\n\n#\n# MFEM Geometry Types (see mesh/geom.hpp):\n#\n# SEGMENT     = 1\n# SQUARE      = 3\n# CUBE        = 5\n#\n\ndimension\n2\n\nelements\n4\n1 3 0 1 5 4\n1 3 1 2 6 5\n1 3 2 3 7 6\n1 3 3 0 4 7\n\nboundary\n8\n1 1 0 1\n1 1 1 2\n1 1 2 3\n1 1 3 0\n1 1 5 4\n1 1 6 5\n1 1 7 6\n1 1 4 7\n\nedges\n12\n0 0 1\n0 4 5\n1 1 2\n1 5 6\n2 2 3\n2 6 7\n3 3 0\n3 7 4\n4 0 4\n4 1 5\n4 2 6\n4 3 7\n\nvertices\n8\n\nknotvectors\n5\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n\nweights\n1\n1\n1\n1\n1\n1\n1\n1\n1\n0.707106781\n1\n0.707106781\n1\n0.707106781\n1\n0.707106781\n1\n1\n1\n1\n0.853553391\n0.853553391\n0.853553391\n0.853553391\n\nFiniteElementSpace\nFiniteElementCollection: NURBS2\nVDim: 2\nOrdering: 1\n\n0 0\n1 0\n1 1\n0 1\n0.358578644 0.358578644\n0.641421356 0.358578644\n0.641421356 0.641421356\n0.358578644 0.641421356\n0.5 0\n0.5 0.217157288\n1 0.5\n0.782842712 0.5\n0.5 1\n0.5 0.782842712\n0 0.5\n0.217157288 0.5\n0.15 0.15\n0.85 0.15\n0.85 0.85\n0.15 0.85\n0.5  0.108578644\n0.891421356 0.5\n0.5 0.891421356\n0.108578644 0.5\n\n\n\n\nThis above file, as well as other examples of NURBS meshes, can be found in \nMFEM's data directory\n. It can be visualized directly with\n\n\nglvis -m square-disc-nurbs.mesh\n\n\n\n\nwhich after several refinements with the \"\ni\n\" key looks like\n\n\n\n\nTo explain MFEM's NURBS mesh file format, we first note that the topological part of the mesh (the \nelements\n and \nboundary\n sections) describe the 4 NURBS patches visible above. We use the vertex numbers as labels, so we only need the number of vertices.\n\n\nIn the NURBS case we need to also provide description of the edges on the patch boundaries and associate a knot vector with each of them. This is done in the \nedges\n section where the first index in each row refers to the knot vector id (from the following \nknotvectors\n section), while the remaining two indexes are the edge vertex numbers.\n\n\nThe position of the NURBS nodes (control points) is given as a NURBS grid function at the end of the file, while the associated weights are listed in the preceding \nweights\n section.\n\n\nSolutions from NURBS discretization spaces are also natively supported. For example here is the approximation for the solution of a simple Poisson problem on a refined version of the above mesh.\n\n\nglvis -m square-disc-nurbs.mesh -g sol.gf", 
            "title": "NURBS Meshes"
        }, 
        {
            "location": "/nurbs/#nurbs-meshes", 
            "text": "", 
            "title": "NURBS Meshes"
        }, 
        {
            "location": "/nurbs/#summary", 
            "text": "A simple tutorial how to visualize NURBS meshes and solutions with GLVis.", 
            "title": "Summary"
        }, 
        {
            "location": "/nurbs/#details", 
            "text": "GLVis provides full support for meshes and discretization spaces based on Non-uniform Rational B-Splines (NURBS). These are treated similarly to general  curvilinear meshes  where the NURBS nodes are specified as a grid function at the end of the mesh file.  For example, here is a simple quadratic NURBS mesh for a square domain with a (perfectly) circular hole in the middle. (The exact representation of conical sections is a major advantage of the NURBS approach over high-order finite elements.)  MFEM NURBS mesh v1.0\n\n#\n# MFEM Geometry Types (see mesh/geom.hpp):\n#\n# SEGMENT     = 1\n# SQUARE      = 3\n# CUBE        = 5\n#\n\ndimension\n2\n\nelements\n4\n1 3 0 1 5 4\n1 3 1 2 6 5\n1 3 2 3 7 6\n1 3 3 0 4 7\n\nboundary\n8\n1 1 0 1\n1 1 1 2\n1 1 2 3\n1 1 3 0\n1 1 5 4\n1 1 6 5\n1 1 7 6\n1 1 4 7\n\nedges\n12\n0 0 1\n0 4 5\n1 1 2\n1 5 6\n2 2 3\n2 6 7\n3 3 0\n3 7 4\n4 0 4\n4 1 5\n4 2 6\n4 3 7\n\nvertices\n8\n\nknotvectors\n5\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n\nweights\n1\n1\n1\n1\n1\n1\n1\n1\n1\n0.707106781\n1\n0.707106781\n1\n0.707106781\n1\n0.707106781\n1\n1\n1\n1\n0.853553391\n0.853553391\n0.853553391\n0.853553391\n\nFiniteElementSpace\nFiniteElementCollection: NURBS2\nVDim: 2\nOrdering: 1\n\n0 0\n1 0\n1 1\n0 1\n0.358578644 0.358578644\n0.641421356 0.358578644\n0.641421356 0.641421356\n0.358578644 0.641421356\n0.5 0\n0.5 0.217157288\n1 0.5\n0.782842712 0.5\n0.5 1\n0.5 0.782842712\n0 0.5\n0.217157288 0.5\n0.15 0.15\n0.85 0.15\n0.85 0.85\n0.15 0.85\n0.5  0.108578644\n0.891421356 0.5\n0.5 0.891421356\n0.108578644 0.5  This above file, as well as other examples of NURBS meshes, can be found in  MFEM's data directory . It can be visualized directly with  glvis -m square-disc-nurbs.mesh  which after several refinements with the \" i \" key looks like   To explain MFEM's NURBS mesh file format, we first note that the topological part of the mesh (the  elements  and  boundary  sections) describe the 4 NURBS patches visible above. We use the vertex numbers as labels, so we only need the number of vertices.  In the NURBS case we need to also provide description of the edges on the patch boundaries and associate a knot vector with each of them. This is done in the  edges  section where the first index in each row refers to the knot vector id (from the following  knotvectors  section), while the remaining two indexes are the edge vertex numbers.  The position of the NURBS nodes (control points) is given as a NURBS grid function at the end of the file, while the associated weights are listed in the preceding  weights  section.  Solutions from NURBS discretization spaces are also natively supported. For example here is the approximation for the solution of a simple Poisson problem on a refined version of the above mesh.  glvis -m square-disc-nurbs.mesh -g sol.gf", 
            "title": "Details"
        }, 
        {
            "location": "/about/", 
            "text": "About GLVis\n\n\nGLVis originates from previous research effort in the (unreleased) \nAggieFEM/aFEM\n project.\n\n\nContributors\n\n\n\n\nRobert Anderson\n\n\nIdo Akkerman\n\n\nThomas Brunner\n\n\nJakub \u010cerven\u00fd\n\n\nVeselin Dobrev\n\n\nTruman Ellis\n\n\nAaron Fisher\n\n\nTzanio Kolev\n \n Project Leader\n\n\nIlya Lashuk\n\n\nRobert Rieben\n\n\nJoachim Sch\u00f6berl\n\n\nMark Stowell\n\n\nVladimir Tomov\n\n\nStanimire Tomov\n\n\nUmberto Villa\n\n\n\n\nLicense\n\n\n\n\nGNU Lesser GPL v2.1\n\n\n\n\n\n\nPlease cite with:\n\n\n@misc{glvis-tool,\n  title = {{GLVis}: Accurate finite element visualization},\n  howpublished = {\\url{glvis.org}}\n}\n\n\n\n\nThis work performed under the auspices of the U.S. Department of Energy\nby Lawrence Livermore Laboratory under Contract DE-AC52-07NA27344.\n\n\nSoftware release number: LLNL-CODE-443271\n\n\n\n\nWebsite built with \nMkDocs\n, \nBootstrap\n\nand \nBootswatch\n. Hosted on \nGitHub\n.", 
            "title": "About"
        }, 
        {
            "location": "/about/#about-glvis", 
            "text": "GLVis originates from previous research effort in the (unreleased)  AggieFEM/aFEM  project.", 
            "title": "About GLVis"
        }, 
        {
            "location": "/about/#contributors", 
            "text": "Robert Anderson  Ido Akkerman  Thomas Brunner  Jakub \u010cerven\u00fd  Veselin Dobrev  Truman Ellis  Aaron Fisher  Tzanio Kolev    Project Leader  Ilya Lashuk  Robert Rieben  Joachim Sch\u00f6berl  Mark Stowell  Vladimir Tomov  Stanimire Tomov  Umberto Villa", 
            "title": "Contributors"
        }, 
        {
            "location": "/about/#license", 
            "text": "GNU Lesser GPL v2.1    Please cite with:  @misc{glvis-tool,\n  title = {{GLVis}: Accurate finite element visualization},\n  howpublished = {\\url{glvis.org}}\n}  This work performed under the auspices of the U.S. Department of Energy\nby Lawrence Livermore Laboratory under Contract DE-AC52-07NA27344.  Software release number: LLNL-CODE-443271   Website built with  MkDocs ,  Bootstrap \nand  Bootswatch . Hosted on  GitHub .", 
            "title": "License"
        }, 
        {
            "location": "/gallery/", 
            "text": "Gallery\n\n\nThis page collects screenshots from various simulations that have used GLVis visualization. Additional images can be found in the \nMFEM Gallery\n.\n\n\n\n\n\n\n\n\n\n\nThe GLVis logo is derived from the \nMetatron model\n at \nbathsheba.com\n. Shown is the magnitude of the projection of a smooth vector field using 4th order Nedelec elements on a second order curved tetrahedral mesh (based on MFEM's \nExample 3\n).\n\n\n\n\n\n\nLocally refined grid in 2D. Simulation with \nMFEM\n.\n\n\n\n\n\n\nUnstructured parallel decomposition of a \nfourth order NURBS mesh\n of the unit ball obtained in the solution of MFEM's parallel \nExample 1\n on 16 processors.\n\n\n\n\n\n\n\n\nCurvilinear 8th order mesh from a triple-point shock simulation in the MFEM-based  \nBLAST\n shock hydrodynamics code. Click for a movie of the evolution of the processor partitioning from a high-resolution parallel run of the problem produced with a \nGLVis script\n.\n\n\n\n\n\n\nAxisymmetric problem with revolved 2D mesh and solution, plus \ncoloring grid functions\n emphasizing mesh elements.\n\n\n\n\n\n\nLevel lines in 2D. Simulation with \nMFEM\n.\n\n\n\n\n\n\n3D Arbitrary Lagrangian-Eulerian (ALE) simulation of a shock-triple point interaction with Q2-Q1 elements in the MFEM-based \nBLAST\n shock hydrodynamics code. Shown are the cutting plane and level surface capabilities of GLVis.\n\n\n\n\n\n\n\n\nThe \nSIAM CSE13\n logo illustrates the decomposition of a hexahedral zone in tetrahedral \"sides\". This and related images can be found in \nthis paper\n.\n\n\n\n\n\n\nStitched parallel results from \nhypre\n's Example 4 on 36 processors.\n\n\n\n\n\n\nOne of the eight order (Q8) basis functions on the reference square. The sub-refinement in GLVis (key 'i') allows for the correct visualization of such high-order functions.", 
            "title": "Gallery"
        }, 
        {
            "location": "/gallery/#gallery", 
            "text": "This page collects screenshots from various simulations that have used GLVis visualization. Additional images can be found in the  MFEM Gallery .      The GLVis logo is derived from the  Metatron model  at  bathsheba.com . Shown is the magnitude of the projection of a smooth vector field using 4th order Nedelec elements on a second order curved tetrahedral mesh (based on MFEM's  Example 3 ).    Locally refined grid in 2D. Simulation with  MFEM .    Unstructured parallel decomposition of a  fourth order NURBS mesh  of the unit ball obtained in the solution of MFEM's parallel  Example 1  on 16 processors.     Curvilinear 8th order mesh from a triple-point shock simulation in the MFEM-based   BLAST  shock hydrodynamics code. Click for a movie of the evolution of the processor partitioning from a high-resolution parallel run of the problem produced with a  GLVis script .    Axisymmetric problem with revolved 2D mesh and solution, plus  coloring grid functions  emphasizing mesh elements.    Level lines in 2D. Simulation with  MFEM .    3D Arbitrary Lagrangian-Eulerian (ALE) simulation of a shock-triple point interaction with Q2-Q1 elements in the MFEM-based  BLAST  shock hydrodynamics code. Shown are the cutting plane and level surface capabilities of GLVis.     The  SIAM CSE13  logo illustrates the decomposition of a hexahedral zone in tetrahedral \"sides\". This and related images can be found in  this paper .    Stitched parallel results from  hypre 's Example 4 on 36 processors.    One of the eight order (Q8) basis functions on the reference square. The sub-refinement in GLVis (key 'i') allows for the correct visualization of such high-order functions.", 
            "title": "Gallery"
        }, 
        {
            "location": "/download/", 
            "text": "Latest Release\n\n\nNew features\n\n/ \nUser documentation\n\n/ \nCode documentation\n\n/ \nSources\n\n\n\n\nDownload glvis-3.1.tgz\n\n\n\n\nPlease use the GitHub \nissue tracker\n\nto report \nbugs\n\nor post \nquestions\n\nor \ncomments\n.\n\n\nAll Releases\n\n\n\n\n\n\n\n\nFilename\n\n\nVersion\n\n\nRelease Date\n\n\nSize\n\n\nSLOC\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nglvis-3.1.tgz\n\n\nv3.1\n\n\nFeb 2016\n\n\n178K\n\n\n24K\n\n\n\n\n\n\n\n\nglvis-3.0.tgz\n\n\nv3.0\n\n\nJan 2015\n\n\n174K\n\n\n23K\n\n\n\n\n\n\n\n\nglvis-d32411e0e4.tgz\n\n\nN/A\n\n\nJul 2014\n\n\n171K\n\n\n22K\n\n\nDevelopment release\n\n\n\n\n\n\nglvis-d15634d151.tgz\n\n\nN/A\n\n\nJul 2013\n\n\n170K\n\n\n22K\n\n\nDevelopment release\n\n\n\n\n\n\nglvis-2.0.tgz\n\n\nv2.0\n\n\nNov 2011\n\n\n158K\n\n\n20K\n\n\n\n\n\n\n\n\nglvis-v1.2.tgz\n\n\nv1.2\n\n\nApr 2011\n\n\n150K\n\n\n19K\n\n\n\n\n\n\n\n\nglvis-v1.1.tgz\n\n\nv1.1\n\n\nSep 2010\n\n\n148K\n\n\n19K\n\n\n\n\n\n\n\n\nglvis-v1.0.tgz\n\n\nv1.0\n\n\nJul 2010\n\n\n144K\n\n\n18K\n\n\nInitial release", 
            "title": "Download"
        }, 
        {
            "location": "/download/#latest-release", 
            "text": "New features \n/  User documentation \n/  Code documentation \n/  Sources   Download glvis-3.1.tgz   Please use the GitHub  issue tracker \nto report  bugs \nor post  questions \nor  comments .", 
            "title": "Latest Release"
        }, 
        {
            "location": "/download/#all-releases", 
            "text": "Filename  Version  Release Date  Size  SLOC  Notes      glvis-3.1.tgz  v3.1  Feb 2016  178K  24K     glvis-3.0.tgz  v3.0  Jan 2015  174K  23K     glvis-d32411e0e4.tgz  N/A  Jul 2014  171K  22K  Development release    glvis-d15634d151.tgz  N/A  Jul 2013  170K  22K  Development release    glvis-2.0.tgz  v2.0  Nov 2011  158K  20K     glvis-v1.2.tgz  v1.2  Apr 2011  150K  19K     glvis-v1.1.tgz  v1.1  Sep 2010  148K  19K     glvis-v1.0.tgz  v1.0  Jul 2010  144K  18K  Initial release", 
            "title": "All Releases"
        }
    ]
}