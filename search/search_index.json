{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Accurate representation of many finite elements , support for arbitrary high-order and NURBS meshes Desktop, Web and Jupyter versions from the same code base glTF export to Blender and augmented reality tools Previous Next GLVis is a lightweight tool for accurate and flexible finite element visualization. Features Accurate functional representation of many finite elements . Support for arbitrary high-order and NURBS meshes. Desktop, Web and Jupyter versions from the same code base. Server mode accepting multiple socket connections. Visualization of parallel meshes and solutions. ... and many more . GLVis is based on the MFEM library and is used in the BLAST , hypre and other projects. See also our Gallery and project news updates . News Date Message May 23, 2022 Version 4.2 released . Jan 20, 2022 New FEM@LLNL seminar series. Feb 19, 2021 Web version at glvis.org/live . Feb 17, 2021 Jupyter support: pip install glvis . Latest Release New features \u250a User documentation \u250a Code documentation \u250a Sources Download glvis-4.2.tgz Use web version Mac \u250a Windows \u250a Older releases \u250a glvis.js \u250a pyglvis Documentation Building \u250a Mesh formats \u250a Parallel \u250a VTK \u250a NURBS New users should start with the options and general use tutorial. We also recommend reading the MFEM project documentation. Contact Use the GitHub issue tracker to report bugs or post questions or comments . See the About page for citation information.","title":"Home"},{"location":"#features","text":"Accurate functional representation of many finite elements . Support for arbitrary high-order and NURBS meshes. Desktop, Web and Jupyter versions from the same code base. Server mode accepting multiple socket connections. Visualization of parallel meshes and solutions. ... and many more . GLVis is based on the MFEM library and is used in the BLAST , hypre and other projects. See also our Gallery and project news updates .","title":"Features"},{"location":"#news","text":"Date Message May 23, 2022 Version 4.2 released . Jan 20, 2022 New FEM@LLNL seminar series. Feb 19, 2021 Web version at glvis.org/live . Feb 17, 2021 Jupyter support: pip install glvis .","title":"News"},{"location":"#latest-release","text":"New features \u250a User documentation \u250a Code documentation \u250a Sources Download glvis-4.2.tgz Use web version Mac \u250a Windows \u250a Older releases \u250a glvis.js \u250a pyglvis","title":"Latest Release"},{"location":"#documentation","text":"Building \u250a Mesh formats \u250a Parallel \u250a VTK \u250a NURBS New users should start with the options and general use tutorial. We also recommend reading the MFEM project documentation.","title":"Documentation"},{"location":"#contact","text":"Use the GitHub issue tracker to report bugs or post questions or comments . See the About page for citation information.","title":"Contact"},{"location":"about/","text":"About GLVis GLVis originates from previous research effort in the (unreleased) AggieFEM/aFEM project. Please cite with: @misc{glvis-tool, title = {{GLVis}: OpenGL Finite Element Visualization Tool}, howpublished = {\\url{glvis.org}}, doi = {10.11578/dc.20171025.1249} } Contributors Ido Akkerman Robert Anderson Julian Andrej Ernesto Aranda Thomas Benson Adrien Bernede Thomas Brunner Jean-Sylvain Camier Jakub \u010cerven\u00fd Lisandro Dalcin Veselin Dobrev Truman Ellis Aaron Fisher Tzanio Kolev \u2014 Project Leader Ilya Lashuk Will Pazner Robert Rieben Joachim Sch\u00f6berl Tom Stitt Mark Stowell Vladimir Tomov Stanimire Tomov Umberto Villa Max Yang Stefano Zampini License BSD This work performed under the auspices of the U.S. Department of Energy by Lawrence Livermore Laboratory under Contract DE-AC52-07NA27344. Software release number: LLNL-CODE-443271. DOI: 10.11578/dc.20171025.1249 . Website built with MkDocs , Bootstrap and Bootswatch . Hosted on GitHub .","title":"About"},{"location":"about/#about-glvis","text":"GLVis originates from previous research effort in the (unreleased) AggieFEM/aFEM project. Please cite with: @misc{glvis-tool, title = {{GLVis}: OpenGL Finite Element Visualization Tool}, howpublished = {\\url{glvis.org}}, doi = {10.11578/dc.20171025.1249} }","title":"About GLVis"},{"location":"about/#contributors","text":"Ido Akkerman Robert Anderson Julian Andrej Ernesto Aranda Thomas Benson Adrien Bernede Thomas Brunner Jean-Sylvain Camier Jakub \u010cerven\u00fd Lisandro Dalcin Veselin Dobrev Truman Ellis Aaron Fisher Tzanio Kolev \u2014 Project Leader Ilya Lashuk Will Pazner Robert Rieben Joachim Sch\u00f6berl Tom Stitt Mark Stowell Vladimir Tomov Stanimire Tomov Umberto Villa Max Yang Stefano Zampini","title":"Contributors"},{"location":"about/#license","text":"BSD This work performed under the auspices of the U.S. Department of Energy by Lawrence Livermore Laboratory under Contract DE-AC52-07NA27344. Software release number: LLNL-CODE-443271. DOI: 10.11578/dc.20171025.1249 . Website built with MkDocs , Bootstrap and Bootswatch . Hosted on GitHub .","title":"License"},{"location":"building/","text":"Building GLVis A simple tutorial how to build and run GLVis together with MFEM. For more details, see the INSTALL file. Dependencies Starting with version 4.0, GLVis requires the following dependencies in order to build and run: SDL2 , GLEW , GLM , Freetype , and Fontconfig . Optional dependencies include libpng and/or libtiff for taking screenshots. Most of these dependencies can be installed through your system's package manager: Ubuntu/Debian (apt-based) apt-get install libfontconfig1-dev libfreetype-dev libsdl2-dev libglew-dev libglm-dev libpng-dev Fedora/RHEL dnf install fontconfig-devel freetype-devel SDL2-devel glew-devel glm-devel libpng-devel Mac OS X (Homebrew) brew install fontconfig freetype sdl2 glew glm libpng Compilation Download MFEM and GLVis (below we assume that we are working with version 4.0) http://mfem.org http://glvis.org Put everything in the same directory: ~> ls glvis-4.0.tgz mfem-4.2.tgz Build the serial version of MFEM: ~> tar -zxvf mfem-4.2.tgz ~> cd mfem-4.2 ~/mfem-4.2> make serial -j Build GLVis: ~> tar -zxvf glvis-4.0.tgz ~> cd glvis-4.0 ~/glvis-4.0> make MFEM_DIR=../mfem-4.2 -j That's it! The glvis executable can be found in the glvis-4.0 directory. Testing and rebuilding To test the build, visualize a mesh with ~/glvis-4.0> ./glvis -m ../mfem-4.2/data/escher.mesh To start a GLVis server, open a new terminal and start glvis without arguments ~/glvis-4.0> ./glvis To rebuild GLVis after changes in MFEM (e.g. if MFEM has rebuild in parallel), do: ~/glvis-4.0> make clean ~/glvis-4.0> make MFEM_DIR=../mfem-4.2 -j Using secure sockets As of version 3.2, GLVis can be built with support for secure sockets using the GnuTLS library through MFEM's class socketstream . This option may be useful in multi-user environment to prevent users from sending/receiving visualization data to/from other users. To enable this support, first configure MFEM version 3.2 or later with ~/mfem-3.2> make config MFEM_USE_GNUTLS=YES For more details consult MFEM's INSTALL file. After configuration, build MFEM and GLVis as usual: ~/mfem-3.2> make -j ~/mfem-3.2> cd ../glvis-3.2 ~/glvis-3.2> make clean && make MFEM_DIR=../mfem-3.2 -j In order to use the secure sockets with the GLVis server and client applications like MFEM's Example 1 , one needs to generate GLVis server and client key pairs. The simplest way to do that is to use the glvis-keygen.sh script in the main GLVis directory: ~/glvis-3.2> bash glvis-keygen.sh \"User Name\" \"user@host.org\" The key generation requires the gpg2 tool from GnuPG . The generated keys are saved in ~/.config/glvis/server and ~/.config/glvis/client . With this option enabled, GLVis will use secure sockets by default, as indicated by the additional message after the logo: ~/glvis-3.2> ./glvis _/_/_/ _/ _/ _/ _/ _/ _/ _/ _/ _/_/_/ _/ _/_/ _/ _/ _/ _/ _/_/ _/ _/ _/ _/ _/ _/ _/_/ _/_/_/ _/_/_/_/ _/ _/ _/_/_/ Generating DH params (1024 bits) ... done. Waiting for data on port 19916 ... The secure sockets can be disabled with the -no-sec or --standard-sockets command line options.","title":"Building GLVis"},{"location":"building/#building-glvis","text":"A simple tutorial how to build and run GLVis together with MFEM. For more details, see the INSTALL file.","title":"Building GLVis"},{"location":"building/#dependencies","text":"Starting with version 4.0, GLVis requires the following dependencies in order to build and run: SDL2 , GLEW , GLM , Freetype , and Fontconfig . Optional dependencies include libpng and/or libtiff for taking screenshots. Most of these dependencies can be installed through your system's package manager:","title":"Dependencies"},{"location":"building/#ubuntudebian-apt-based","text":"apt-get install libfontconfig1-dev libfreetype-dev libsdl2-dev libglew-dev libglm-dev libpng-dev","title":"Ubuntu/Debian (apt-based)"},{"location":"building/#fedorarhel","text":"dnf install fontconfig-devel freetype-devel SDL2-devel glew-devel glm-devel libpng-devel","title":"Fedora/RHEL"},{"location":"building/#mac-os-x-homebrew","text":"brew install fontconfig freetype sdl2 glew glm libpng","title":"Mac OS X (Homebrew)"},{"location":"building/#compilation","text":"Download MFEM and GLVis (below we assume that we are working with version 4.0) http://mfem.org http://glvis.org Put everything in the same directory: ~> ls glvis-4.0.tgz mfem-4.2.tgz Build the serial version of MFEM: ~> tar -zxvf mfem-4.2.tgz ~> cd mfem-4.2 ~/mfem-4.2> make serial -j Build GLVis: ~> tar -zxvf glvis-4.0.tgz ~> cd glvis-4.0 ~/glvis-4.0> make MFEM_DIR=../mfem-4.2 -j That's it! The glvis executable can be found in the glvis-4.0 directory.","title":"Compilation"},{"location":"building/#testing-and-rebuilding","text":"To test the build, visualize a mesh with ~/glvis-4.0> ./glvis -m ../mfem-4.2/data/escher.mesh To start a GLVis server, open a new terminal and start glvis without arguments ~/glvis-4.0> ./glvis To rebuild GLVis after changes in MFEM (e.g. if MFEM has rebuild in parallel), do: ~/glvis-4.0> make clean ~/glvis-4.0> make MFEM_DIR=../mfem-4.2 -j","title":"Testing and rebuilding"},{"location":"building/#using-secure-sockets","text":"As of version 3.2, GLVis can be built with support for secure sockets using the GnuTLS library through MFEM's class socketstream . This option may be useful in multi-user environment to prevent users from sending/receiving visualization data to/from other users. To enable this support, first configure MFEM version 3.2 or later with ~/mfem-3.2> make config MFEM_USE_GNUTLS=YES For more details consult MFEM's INSTALL file. After configuration, build MFEM and GLVis as usual: ~/mfem-3.2> make -j ~/mfem-3.2> cd ../glvis-3.2 ~/glvis-3.2> make clean && make MFEM_DIR=../mfem-3.2 -j In order to use the secure sockets with the GLVis server and client applications like MFEM's Example 1 , one needs to generate GLVis server and client key pairs. The simplest way to do that is to use the glvis-keygen.sh script in the main GLVis directory: ~/glvis-3.2> bash glvis-keygen.sh \"User Name\" \"user@host.org\" The key generation requires the gpg2 tool from GnuPG . The generated keys are saved in ~/.config/glvis/server and ~/.config/glvis/client . With this option enabled, GLVis will use secure sockets by default, as indicated by the additional message after the logo: ~/glvis-3.2> ./glvis _/_/_/ _/ _/ _/ _/ _/ _/ _/ _/ _/_/_/ _/ _/_/ _/ _/ _/ _/ _/_/ _/ _/ _/ _/ _/ _/ _/_/ _/_/_/ _/_/_/_/ _/ _/ _/_/_/ Generating DH params (1024 bits) ... done. Waiting for data on port 19916 ... The secure sockets can be disabled with the -no-sec or --standard-sockets command line options.","title":"Using secure sockets"},{"location":"curvilinear-vtk-meshes/","text":"Curvilinear VTK Meshes Summary A simple tutorial how to visualize curvilinear meshes in VTK format with GLVis. Details GLVis supports quadratic triangular, quadrilaterals, tetrahedral and hexahedral curvilinear meshes in VTK format. This format is described in the VTK file format documentation . The local numbering of degrees of freedom for the biquadratic quads and triquadratic hexes can be found in the Doxygen reference of the vtkBiQuadraticQuad and vtkTriQuadraticHexahedron classes. Currently VTK does not support cubic, and higher-order meshes. As an example, consider a simple curved quadrilateral saved in a file quad.vtk : # vtk DataFile Version 3.0 Generated by MFEM ASCII DATASET UNSTRUCTURED_GRID POINTS 9 double 0 0 0 1 0 0 1 1 0 0.1 0.9 0 0.5 -0.05 0 0.9 0.5 0 0.5 1 0 0 0.5 0 0.45 0.55 0 CELLS 1 10 9 0 1 2 3 4 5 6 7 8 CELL_TYPES 1 28 CELL_DATA 1 SCALARS material int LOOKUP_TABLE default 1 Visualizing it with \" glvis -m quad.vtk \" and typing \" Aemooo \" in the GLVis window we get: The \" o \" key increases the reference element subdivision which gives an increasingly better approximation of the actual curvature of the element. To view the curvature of the mapping inside the element we can use the \"O\" key, e.g., glvis -m quad.vtk -k \"AemOOooo\" Here is a slightly more complicated quadratic quadrilateral mesh example (the different colors in the GLVis window are used to distinguish neighboring elements): glvis -m star-q2.vtk -k \"Am\" GLVis can also handle quadratic triangular meshes: glvis -m square-disc-p2.vtk -k \"Am\" As well as quadratic tetrahedral and quadratic hexahedral VTK meshes: glvis -m escher-p2.vtk -k \"Aaaaooooo**************\" glvis -m fichera-q2.vtk -k \"Aaaaooooo*****\"","title":"Curvilinear VTK Meshes"},{"location":"curvilinear-vtk-meshes/#curvilinear-vtk-meshes","text":"","title":"Curvilinear VTK Meshes"},{"location":"curvilinear-vtk-meshes/#summary","text":"A simple tutorial how to visualize curvilinear meshes in VTK format with GLVis.","title":"Summary"},{"location":"curvilinear-vtk-meshes/#details","text":"GLVis supports quadratic triangular, quadrilaterals, tetrahedral and hexahedral curvilinear meshes in VTK format. This format is described in the VTK file format documentation . The local numbering of degrees of freedom for the biquadratic quads and triquadratic hexes can be found in the Doxygen reference of the vtkBiQuadraticQuad and vtkTriQuadraticHexahedron classes. Currently VTK does not support cubic, and higher-order meshes. As an example, consider a simple curved quadrilateral saved in a file quad.vtk : # vtk DataFile Version 3.0 Generated by MFEM ASCII DATASET UNSTRUCTURED_GRID POINTS 9 double 0 0 0 1 0 0 1 1 0 0.1 0.9 0 0.5 -0.05 0 0.9 0.5 0 0.5 1 0 0 0.5 0 0.45 0.55 0 CELLS 1 10 9 0 1 2 3 4 5 6 7 8 CELL_TYPES 1 28 CELL_DATA 1 SCALARS material int LOOKUP_TABLE default 1 Visualizing it with \" glvis -m quad.vtk \" and typing \" Aemooo \" in the GLVis window we get: The \" o \" key increases the reference element subdivision which gives an increasingly better approximation of the actual curvature of the element. To view the curvature of the mapping inside the element we can use the \"O\" key, e.g., glvis -m quad.vtk -k \"AemOOooo\" Here is a slightly more complicated quadratic quadrilateral mesh example (the different colors in the GLVis window are used to distinguish neighboring elements): glvis -m star-q2.vtk -k \"Am\" GLVis can also handle quadratic triangular meshes: glvis -m square-disc-p2.vtk -k \"Am\" As well as quadratic tetrahedral and quadratic hexahedral VTK meshes: glvis -m escher-p2.vtk -k \"Aaaaooooo**************\" glvis -m fichera-q2.vtk -k \"Aaaaooooo*****\"","title":"Details"},{"location":"download/","text":"Latest Release New features \u250a User documentation \u250a Code documentation \u250a Sources glvis-4.2.tgz Mac Windows Web version Please use the GitHub issue tracker to report bugs or post questions or comments . All Releases Filename Version Release Date Size SLOC Notes glvis-4.2.tgz v4.2 May 2022 2.4M 37K glTF export glvis-4.1.tgz v4.1 Aug 2021 2.4M 34K glvis-4.0.tgz v4.0 Dec 2020 1.3M 33K modern OpenGL, BSD license glvis-3.4.tgz v3.4 May 2018 199K 27K glvis-3.3.tgz v3.3 Jan 2017 180K 25K glvis-3.2.tgz v3.2 Jun 2016 182K 25K secure sockets glvis-3.1.tgz v3.1 Feb 2016 178K 24K glvis-3.0.tgz v3.0 Jan 2015 174K 23K glvis-2.0.tgz v2.0 Nov 2011 158K 20K parallel meshes + functions glvis-v1.2.tgz v1.2 Apr 2011 150K 19K glvis-v1.1.tgz v1.1 Sep 2010 148K 19K glvis-v1.0.tgz v1.0 Jul 2010 144K 18K initial release","title":"Download"},{"location":"download/#latest-release","text":"New features \u250a User documentation \u250a Code documentation \u250a Sources glvis-4.2.tgz Mac Windows Web version Please use the GitHub issue tracker to report bugs or post questions or comments .","title":"Latest Release"},{"location":"download/#all-releases","text":"Filename Version Release Date Size SLOC Notes glvis-4.2.tgz v4.2 May 2022 2.4M 37K glTF export glvis-4.1.tgz v4.1 Aug 2021 2.4M 34K glvis-4.0.tgz v4.0 Dec 2020 1.3M 33K modern OpenGL, BSD license glvis-3.4.tgz v3.4 May 2018 199K 27K glvis-3.3.tgz v3.3 Jan 2017 180K 25K glvis-3.2.tgz v3.2 Jun 2016 182K 25K secure sockets glvis-3.1.tgz v3.1 Feb 2016 178K 24K glvis-3.0.tgz v3.0 Jan 2015 174K 23K glvis-2.0.tgz v2.0 Nov 2011 158K 20K parallel meshes + functions glvis-v1.2.tgz v1.2 Apr 2011 150K 19K glvis-v1.1.tgz v1.1 Sep 2010 148K 19K glvis-v1.0.tgz v1.0 Jul 2010 144K 18K initial release","title":"All Releases"},{"location":"features/","text":"GLVis Features The goal of GLVis is to enable research and development of general finite element discretization algorithms through accurate OpenGL visualization, and tight integration with the MFEM library. Though depending on MFEM for its finite element dictionary, GLVis can be used independently for parallel and serial visualization. For example, the hypre library includes scripts for displaying the numerical results from its parallel example codes through GLVis. Accurate Visualization GLVis uses OpenGL with interactive refinement to accurately represent curved high-order meshes and a wide variety of finite element grid functions defined on them. GLVis is based on the modular finite element methods library MFEM , which supports in particular: 1D, 2D, 3D volume and surface meshes, triangular, quadrilateral, tetrahedral and hexahedral meshes, general curvilinear and NURBS meshes, input in unstructured VTK mesh format , support for Gmsh, CUBIT, NETGEN and TrueGrid meshes, arbitrary high-order, scalar and vector finite element and NURBS solutions, accurate cutting planes and level lines/surfaces, visualization of parallel meshes and solutions. Lightweight and Convenient GLVis has a fast keystroke-based interface and uses modern OpenGL that takes advantage of hardware acceleration in modern GPUs. It has a number of convenient features, including: unlimited number of refinement and de-refinement levels, interactive rotation, translation and scaling with the mouse, support for different perspectives, materials, lighting, color schemes and transparency, processor and element shrinking for better visualization of the interior of 3D meshes, antialiased meshes and fonts, screenshots in PNG or TIFF format. Flexible Server and Scripting Support When started without any options, GLVis establishes a server , which waits for socket connections and visualizes any received data in a separate interactive window. This enables: simultaneous visualization of multiple fields/meshes in separate GLVis windows, persistent visualization of time-evolving fields, local visualization of parallel meshes and solutions sent to the server by separate socket connections from each core of a remote parallel machine, saving and displaying of socket stream data , support for secure sockets using GnuTLS. GLVis can also run a batch sequence of commands (GLVis scripts), which enable precise control of particular visualization scenes, and can be useful for making animations. Native and Web Versions GLVis runs natively on Mac, Linux, and Windows. It can also run a browser, using the web version , or a Jupyter notebook, using pyglvis or xeus-glvis . On Mac, GLVis can be built as a native app bundle that can be added to the Dock, double-clicked in the Finder, etc. Open Source GLVis is an open-source software, and can be freely used under the terms of the BSD license.","title":"Features"},{"location":"features/#glvis-features","text":"The goal of GLVis is to enable research and development of general finite element discretization algorithms through accurate OpenGL visualization, and tight integration with the MFEM library. Though depending on MFEM for its finite element dictionary, GLVis can be used independently for parallel and serial visualization. For example, the hypre library includes scripts for displaying the numerical results from its parallel example codes through GLVis.","title":"GLVis Features"},{"location":"features/#accurate-visualization","text":"GLVis uses OpenGL with interactive refinement to accurately represent curved high-order meshes and a wide variety of finite element grid functions defined on them. GLVis is based on the modular finite element methods library MFEM , which supports in particular: 1D, 2D, 3D volume and surface meshes, triangular, quadrilateral, tetrahedral and hexahedral meshes, general curvilinear and NURBS meshes, input in unstructured VTK mesh format , support for Gmsh, CUBIT, NETGEN and TrueGrid meshes, arbitrary high-order, scalar and vector finite element and NURBS solutions, accurate cutting planes and level lines/surfaces, visualization of parallel meshes and solutions.","title":"Accurate Visualization"},{"location":"features/#lightweight-and-convenient","text":"GLVis has a fast keystroke-based interface and uses modern OpenGL that takes advantage of hardware acceleration in modern GPUs. It has a number of convenient features, including: unlimited number of refinement and de-refinement levels, interactive rotation, translation and scaling with the mouse, support for different perspectives, materials, lighting, color schemes and transparency, processor and element shrinking for better visualization of the interior of 3D meshes, antialiased meshes and fonts, screenshots in PNG or TIFF format.","title":"Lightweight and Convenient"},{"location":"features/#flexible-server-and-scripting-support","text":"When started without any options, GLVis establishes a server , which waits for socket connections and visualizes any received data in a separate interactive window. This enables: simultaneous visualization of multiple fields/meshes in separate GLVis windows, persistent visualization of time-evolving fields, local visualization of parallel meshes and solutions sent to the server by separate socket connections from each core of a remote parallel machine, saving and displaying of socket stream data , support for secure sockets using GnuTLS. GLVis can also run a batch sequence of commands (GLVis scripts), which enable precise control of particular visualization scenes, and can be useful for making animations.","title":"Flexible Server and Scripting Support"},{"location":"features/#native-and-web-versions","text":"GLVis runs natively on Mac, Linux, and Windows. It can also run a browser, using the web version , or a Jupyter notebook, using pyglvis or xeus-glvis . On Mac, GLVis can be built as a native app bundle that can be added to the Dock, double-clicked in the Finder, etc.","title":"Native and Web Versions"},{"location":"features/#open-source","text":"GLVis is an open-source software, and can be freely used under the terms of the BSD license.","title":"Open Source"},{"location":"gallery/","text":"Gallery This page collects screenshots from various simulations that have used GLVis visualization. Additional images can be found in the MFEM Gallery . The GLVis logo is derived from the Metatron model at bathsheba.com . Shown is the magnitude of the projection of a smooth vector field using 4th order Nedelec elements on a second order curved tetrahedral mesh (based on MFEM's Example 3 ). Axisymmetric problem with revolved 2D mesh and solution, plus coloring grid functions emphasizing mesh elements. See also the video . Unstructured parallel decomposition of a fourth order NURBS mesh of the unit ball obtained in the solution of MFEM's parallel Example 1 on 16 processors. One of the eight order (Q8) basis functions on the reference square. The sub-refinement in GLVis (key 'i') allows for the correct visualization of such high-order functions. GLVis model opened in augmented reality with the glTF model viewer . Curvilinear 8th order mesh from a triple-point shock simulation in the MFEM-based BLAST shock hydrodynamics code. Click for a movie of the evolution of the processor partitioning from a high-resolution parallel run of the problem produced with a GLVis script . Raytraced glTF model in Blender which was exported from GLVis with the 'G' key. The mesh faces have been cut with 'Ctrl+F3' 3D Arbitrary Lagrangian-Eulerian (ALE) simulation of a shock-triple point interaction with Q2-Q1 elements in the MFEM-based BLAST shock hydrodynamics code. Shown are the cutting plane and level surface capabilities of GLVis. Parallel partitioning of a non-conforming adaptively refined mesh between 2048 processors based on splitting a space-filling (Hilbert) curve. Level lines in 2D. Simulation with MFEM . The SIAM CSE13 logo illustrates the decomposition of a hexahedral zone in tetrahedral \"sides\". This and related images can be found in this paper . The vector field solution of grad-div problem on a periodic mesh computed with hybridized 3rd order Raviart-Thomas elements. Lines correspond to backward Cartesian displacements (key 'd' in GLVis). Stitched parallel results from hypre 's Example 4 on 36 processors. The solution of the Laplace problem on a 3D NURBS mesh. Shown are the solution values in a cutting plane and one of the internal boundaries. Locally refined grid in 2D. Simulation with MFEM .","title":"Gallery"},{"location":"gallery/#gallery","text":"This page collects screenshots from various simulations that have used GLVis visualization. Additional images can be found in the MFEM Gallery . The GLVis logo is derived from the Metatron model at bathsheba.com . Shown is the magnitude of the projection of a smooth vector field using 4th order Nedelec elements on a second order curved tetrahedral mesh (based on MFEM's Example 3 ). Axisymmetric problem with revolved 2D mesh and solution, plus coloring grid functions emphasizing mesh elements. See also the video . Unstructured parallel decomposition of a fourth order NURBS mesh of the unit ball obtained in the solution of MFEM's parallel Example 1 on 16 processors. One of the eight order (Q8) basis functions on the reference square. The sub-refinement in GLVis (key 'i') allows for the correct visualization of such high-order functions. GLVis model opened in augmented reality with the glTF model viewer . Curvilinear 8th order mesh from a triple-point shock simulation in the MFEM-based BLAST shock hydrodynamics code. Click for a movie of the evolution of the processor partitioning from a high-resolution parallel run of the problem produced with a GLVis script . Raytraced glTF model in Blender which was exported from GLVis with the 'G' key. The mesh faces have been cut with 'Ctrl+F3' 3D Arbitrary Lagrangian-Eulerian (ALE) simulation of a shock-triple point interaction with Q2-Q1 elements in the MFEM-based BLAST shock hydrodynamics code. Shown are the cutting plane and level surface capabilities of GLVis. Parallel partitioning of a non-conforming adaptively refined mesh between 2048 processors based on splitting a space-filling (Hilbert) curve. Level lines in 2D. Simulation with MFEM . The SIAM CSE13 logo illustrates the decomposition of a hexahedral zone in tetrahedral \"sides\". This and related images can be found in this paper . The vector field solution of grad-div problem on a periodic mesh computed with hybridized 3rd order Raviart-Thomas elements. Lines correspond to backward Cartesian displacements (key 'd' in GLVis). Stitched parallel results from hypre 's Example 4 on 36 processors. The solution of the Laplace problem on a 3D NURBS mesh. Shown are the solution values in a cutting plane and one of the internal boundaries. Locally refined grid in 2D. Simulation with MFEM .","title":"Gallery"},{"location":"mesh-formats/","text":"Mesh Formats Summary Description of the various mesh formats that can be used with GLVis. Details GLVis supports a number of mesh formats, including: The MFEM mesh v1.0 format, which can describe very general meshes based on any finite element grid function supported by MFEM, including NURBS meshes . The VTK unstructured mesh format, for triangular, quadrilateral, tetrahedral and hexahedral meshes. See the curvilinear VTK tutorial for more details. Some examples of VTK meshes can be found in MFEM's data directory . The Gmsh ASCII and binary formats for 2D and 3D meshes. The CUBIT meshes through the Genesis (NetCDF) binary format. The NETGEN triangular and tetrahedral mesh formats. The TrueGrid hexahedral mesh format. MFEM mesh v1.0 This is the default format in GLVis. It can be used to describe simple (triangular, quadrilateral, tetrahedral and hexahedral meshes with straight edges) or complicated (curvilinear and more general) meshes. Straight meshes In the simple case of a mesh with straight edges the format looks as follows MFEM mesh v1.0 # Space dimension: 2 or 3 dimension <dimension> # Mesh elements, e.g. tetrahedrons (4) elements <number of elements> <element attribute> <geometry type> <vertex index 1> ... <vertex index m> ... # Mesh faces/edges on the boundary, e.g. triangles (2) boundary <number of boundary elements> <boundary element attribute> <geometry type> <vertex index 1> ... <vertex index m> ... # Vertex coordinates vertices <number of vertices> <vdim> <coordinate 1> ... <coordinate <vdim>> ... Lines starting with \"#\" denote comments. The supported geometry types are: POINT = 0 SEGMENT = 1 TRIANGLE = 2 SQUARE = 3 TETRAHEDRON = 4 CUBE = 5 see the comments in this source file for more details. For example, the beam-quad.mesh file from MFEM looks like this: MFEM mesh v1.0 dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 8 17 16 boundary 18 3 1 1 0 3 1 2 1 3 1 3 2 3 1 4 3 3 1 5 4 3 1 6 5 3 1 7 6 3 1 8 7 3 1 9 10 3 1 10 11 3 1 11 12 3 1 12 13 3 1 13 14 3 1 14 15 3 1 15 16 3 1 16 17 1 1 0 9 2 1 17 8 vertices 18 2 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 which corresponds to the mesh visualized with glvis -m beam-quad.mesh -k \"Ame****\" Curvilinear and more general meshes The MFEM mesh v1.0 format also support the general description of meshes based on a vector finite element grid function with degrees of freedom in the \"nodes\" of the mesh: MFEM mesh v1.0 # Space dimension: 2 or 3 dimension <dimension> # Mesh elements, e.g. tetrahedrons (4) elements <number of elements> <element attribute> <geometry type> <vertex index 1> ... <vertex index m> ... # Mesh faces/edges on the boundary, e.g. triangles (2) boundary <number of boundary elements> <boundary element attribute> <geometry type> <vertex index 1> ... <vertex index m> ... # Number of vertices (no coordinates) vertices <number of vertices> # Mesh nodes as degrees of freedom of a finite element grid function nodes FiniteElementSpace FiniteElementCollection: <finite element collection> VDim: <dimension> Ordering: 0 <x-coordinate degrees of freedom> ... <y-coordinate degrees of freedom> ... <z-coordinate degrees of freedom> ... Some possible finite element collection choices are: Linear , Quadratic and Cubic corresponding to curvilinear P1/Q1, P2/Q2 and P3/Q3 meshes. The algorithm for the numbering of the degrees of freedom can be found in MFEM's source code . For example, the escher-p3.mesh from MFEM's data directory describes a tetrahedral mesh with nodes given by a P3 vector Lagrangian finite element function. Visualizing this mesh with glvis -m escher-p3.mesh -k \"Aaaaoooooooooo**************tt\" we get: NURBS meshes NURBS meshes and functions are fully supported in GLVis. For example, glvis -m pipe-nurbs.mesh produces after some refinement (key \" o \") and mouse manipulations More details about the NURBS mesh format can be found in the separate NURBS tutorial .","title":"Mesh Formats"},{"location":"mesh-formats/#mesh-formats","text":"","title":"Mesh Formats"},{"location":"mesh-formats/#summary","text":"Description of the various mesh formats that can be used with GLVis.","title":"Summary"},{"location":"mesh-formats/#details","text":"GLVis supports a number of mesh formats, including: The MFEM mesh v1.0 format, which can describe very general meshes based on any finite element grid function supported by MFEM, including NURBS meshes . The VTK unstructured mesh format, for triangular, quadrilateral, tetrahedral and hexahedral meshes. See the curvilinear VTK tutorial for more details. Some examples of VTK meshes can be found in MFEM's data directory . The Gmsh ASCII and binary formats for 2D and 3D meshes. The CUBIT meshes through the Genesis (NetCDF) binary format. The NETGEN triangular and tetrahedral mesh formats. The TrueGrid hexahedral mesh format.","title":"Details"},{"location":"mesh-formats/#mfem-mesh-v10","text":"This is the default format in GLVis. It can be used to describe simple (triangular, quadrilateral, tetrahedral and hexahedral meshes with straight edges) or complicated (curvilinear and more general) meshes.","title":"MFEM mesh v1.0"},{"location":"mesh-formats/#straight-meshes","text":"In the simple case of a mesh with straight edges the format looks as follows MFEM mesh v1.0 # Space dimension: 2 or 3 dimension <dimension> # Mesh elements, e.g. tetrahedrons (4) elements <number of elements> <element attribute> <geometry type> <vertex index 1> ... <vertex index m> ... # Mesh faces/edges on the boundary, e.g. triangles (2) boundary <number of boundary elements> <boundary element attribute> <geometry type> <vertex index 1> ... <vertex index m> ... # Vertex coordinates vertices <number of vertices> <vdim> <coordinate 1> ... <coordinate <vdim>> ... Lines starting with \"#\" denote comments. The supported geometry types are: POINT = 0 SEGMENT = 1 TRIANGLE = 2 SQUARE = 3 TETRAHEDRON = 4 CUBE = 5 see the comments in this source file for more details. For example, the beam-quad.mesh file from MFEM looks like this: MFEM mesh v1.0 dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 8 17 16 boundary 18 3 1 1 0 3 1 2 1 3 1 3 2 3 1 4 3 3 1 5 4 3 1 6 5 3 1 7 6 3 1 8 7 3 1 9 10 3 1 10 11 3 1 11 12 3 1 12 13 3 1 13 14 3 1 14 15 3 1 15 16 3 1 16 17 1 1 0 9 2 1 17 8 vertices 18 2 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 which corresponds to the mesh visualized with glvis -m beam-quad.mesh -k \"Ame****\"","title":"Straight meshes"},{"location":"mesh-formats/#curvilinear-and-more-general-meshes","text":"The MFEM mesh v1.0 format also support the general description of meshes based on a vector finite element grid function with degrees of freedom in the \"nodes\" of the mesh: MFEM mesh v1.0 # Space dimension: 2 or 3 dimension <dimension> # Mesh elements, e.g. tetrahedrons (4) elements <number of elements> <element attribute> <geometry type> <vertex index 1> ... <vertex index m> ... # Mesh faces/edges on the boundary, e.g. triangles (2) boundary <number of boundary elements> <boundary element attribute> <geometry type> <vertex index 1> ... <vertex index m> ... # Number of vertices (no coordinates) vertices <number of vertices> # Mesh nodes as degrees of freedom of a finite element grid function nodes FiniteElementSpace FiniteElementCollection: <finite element collection> VDim: <dimension> Ordering: 0 <x-coordinate degrees of freedom> ... <y-coordinate degrees of freedom> ... <z-coordinate degrees of freedom> ... Some possible finite element collection choices are: Linear , Quadratic and Cubic corresponding to curvilinear P1/Q1, P2/Q2 and P3/Q3 meshes. The algorithm for the numbering of the degrees of freedom can be found in MFEM's source code . For example, the escher-p3.mesh from MFEM's data directory describes a tetrahedral mesh with nodes given by a P3 vector Lagrangian finite element function. Visualizing this mesh with glvis -m escher-p3.mesh -k \"Aaaaoooooooooo**************tt\" we get:","title":"Curvilinear and more general meshes"},{"location":"mesh-formats/#nurbs-meshes","text":"NURBS meshes and functions are fully supported in GLVis. For example, glvis -m pipe-nurbs.mesh produces after some refinement (key \" o \") and mouse manipulations More details about the NURBS mesh format can be found in the separate NURBS tutorial .","title":"NURBS meshes"},{"location":"news/","text":"All News Updates May 23, 2022 Version 4.2 released . Jan 20, 2022 FEM@LLNL seminar series starting. Aug 31, 2021 Version 4.1 released . Jul 10, 2021 The inaugural MFEM Community Workshop will take place on October 20th, 2021. Feb 19, 2021 Web version at glvis.org/live . Feb 17, 2021 Jupyter support: pip install glvis . Dec 11, 2020 Version 4.0 released . Dec 11, 2020 Switched to a BSD software license. May 29, 2018 Version 3.4 released . Jan 28, 2017 Version 3.3 released . Dec 15, 2016 Postdoc position for exascale computing with MFEM. Jun 30, 2016 Version 3.2 released. Mar 4, 2016 New LLNL open-source software Blog and Twitter . Feb 5, 2016 Version 3.1 released. Feb 5, 2016 GLVis-generated images part of the Art of Science exhibition at the Livermore public library. Aug 18, 2015 Moved to GitHub and glvis.org . Jan 26, 2015 Version 3.0 released.","title":"_News"},{"location":"news/#all-news-updates","text":"May 23, 2022 Version 4.2 released . Jan 20, 2022 FEM@LLNL seminar series starting. Aug 31, 2021 Version 4.1 released . Jul 10, 2021 The inaugural MFEM Community Workshop will take place on October 20th, 2021. Feb 19, 2021 Web version at glvis.org/live . Feb 17, 2021 Jupyter support: pip install glvis . Dec 11, 2020 Version 4.0 released . Dec 11, 2020 Switched to a BSD software license. May 29, 2018 Version 3.4 released . Jan 28, 2017 Version 3.3 released . Dec 15, 2016 Postdoc position for exascale computing with MFEM. Jun 30, 2016 Version 3.2 released. Mar 4, 2016 New LLNL open-source software Blog and Twitter . Feb 5, 2016 Version 3.1 released. Feb 5, 2016 GLVis-generated images part of the Art of Science exhibition at the Livermore public library. Aug 18, 2015 Moved to GitHub and glvis.org . Jan 26, 2015 Version 3.0 released.","title":"All News Updates"},{"location":"nurbs/","text":"NURBS Meshes Summary A simple tutorial how to visualize NURBS meshes and solutions with GLVis. Details GLVis provides full support for meshes and discretization spaces based on Non-uniform Rational B-Splines (NURBS). These are treated similarly to general curvilinear meshes where the NURBS nodes are specified as a grid function at the end of the mesh file. For example, here is a simple quadratic NURBS mesh for a square domain with a (perfectly) circular hole in the middle. (The exact representation of conical sections is a major advantage of the NURBS approach over high-order finite elements.) MFEM NURBS mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # SEGMENT = 1 # SQUARE = 3 # CUBE = 5 # dimension 2 elements 4 1 3 0 1 5 4 1 3 1 2 6 5 1 3 2 3 7 6 1 3 3 0 4 7 boundary 8 1 1 0 1 1 1 1 2 1 1 2 3 1 1 3 0 1 1 5 4 1 1 6 5 1 1 7 6 1 1 4 7 edges 12 0 0 1 0 4 5 1 1 2 1 5 6 2 2 3 2 6 7 3 3 0 3 7 4 4 0 4 4 1 5 4 2 6 4 3 7 vertices 8 knotvectors 5 2 3 0 0 0 1 1 1 2 3 0 0 0 1 1 1 2 3 0 0 0 1 1 1 2 3 0 0 0 1 1 1 2 3 0 0 0 1 1 1 weights 1 1 1 1 1 1 1 1 1 0.707106781 1 0.707106781 1 0.707106781 1 0.707106781 1 1 1 1 0.853553391 0.853553391 0.853553391 0.853553391 FiniteElementSpace FiniteElementCollection: NURBS2 VDim: 2 Ordering: 1 0 0 1 0 1 1 0 1 0.358578644 0.358578644 0.641421356 0.358578644 0.641421356 0.641421356 0.358578644 0.641421356 0.5 0 0.5 0.217157288 1 0.5 0.782842712 0.5 0.5 1 0.5 0.782842712 0 0.5 0.217157288 0.5 0.15 0.15 0.85 0.15 0.85 0.85 0.15 0.85 0.5 0.108578644 0.891421356 0.5 0.5 0.891421356 0.108578644 0.5 This above file, as well as other examples of NURBS meshes, can be found in MFEM's data directory . It can be visualized directly with glvis -m square-disc-nurbs.mesh which after pressing \" e \", \" m \", \" A \", and several refinements with the \" o \" key looks like To explain MFEM's NURBS mesh file format, we first note that the topological part of the mesh (the elements and boundary sections) describe the 4 NURBS patches visible above. We use the vertex numbers as labels, so we only need the number of vertices. In the NURBS case we need to also provide description of the edges on the patch boundaries and associate a knot vector with each of them. This is done in the edges section where the first index in each row refers to the knot vector id (from the following knotvectors section), while the remaining two indexes are the edge vertex numbers. The position of the NURBS nodes (control points) is given as a NURBS grid function at the end of the file, while the associated weights are listed in the preceding weights section. Solutions from NURBS discretization spaces are also natively supported. For example here is the approximation for the solution of a simple Poisson problem on a refined version of the above mesh. glvis -m square-disc-nurbs.mesh -g sol.gf","title":"NURBS Meshes"},{"location":"nurbs/#nurbs-meshes","text":"","title":"NURBS Meshes"},{"location":"nurbs/#summary","text":"A simple tutorial how to visualize NURBS meshes and solutions with GLVis.","title":"Summary"},{"location":"nurbs/#details","text":"GLVis provides full support for meshes and discretization spaces based on Non-uniform Rational B-Splines (NURBS). These are treated similarly to general curvilinear meshes where the NURBS nodes are specified as a grid function at the end of the mesh file. For example, here is a simple quadratic NURBS mesh for a square domain with a (perfectly) circular hole in the middle. (The exact representation of conical sections is a major advantage of the NURBS approach over high-order finite elements.) MFEM NURBS mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # SEGMENT = 1 # SQUARE = 3 # CUBE = 5 # dimension 2 elements 4 1 3 0 1 5 4 1 3 1 2 6 5 1 3 2 3 7 6 1 3 3 0 4 7 boundary 8 1 1 0 1 1 1 1 2 1 1 2 3 1 1 3 0 1 1 5 4 1 1 6 5 1 1 7 6 1 1 4 7 edges 12 0 0 1 0 4 5 1 1 2 1 5 6 2 2 3 2 6 7 3 3 0 3 7 4 4 0 4 4 1 5 4 2 6 4 3 7 vertices 8 knotvectors 5 2 3 0 0 0 1 1 1 2 3 0 0 0 1 1 1 2 3 0 0 0 1 1 1 2 3 0 0 0 1 1 1 2 3 0 0 0 1 1 1 weights 1 1 1 1 1 1 1 1 1 0.707106781 1 0.707106781 1 0.707106781 1 0.707106781 1 1 1 1 0.853553391 0.853553391 0.853553391 0.853553391 FiniteElementSpace FiniteElementCollection: NURBS2 VDim: 2 Ordering: 1 0 0 1 0 1 1 0 1 0.358578644 0.358578644 0.641421356 0.358578644 0.641421356 0.641421356 0.358578644 0.641421356 0.5 0 0.5 0.217157288 1 0.5 0.782842712 0.5 0.5 1 0.5 0.782842712 0 0.5 0.217157288 0.5 0.15 0.15 0.85 0.15 0.85 0.85 0.15 0.85 0.5 0.108578644 0.891421356 0.5 0.5 0.891421356 0.108578644 0.5 This above file, as well as other examples of NURBS meshes, can be found in MFEM's data directory . It can be visualized directly with glvis -m square-disc-nurbs.mesh which after pressing \" e \", \" m \", \" A \", and several refinements with the \" o \" key looks like To explain MFEM's NURBS mesh file format, we first note that the topological part of the mesh (the elements and boundary sections) describe the 4 NURBS patches visible above. We use the vertex numbers as labels, so we only need the number of vertices. In the NURBS case we need to also provide description of the edges on the patch boundaries and associate a knot vector with each of them. This is done in the edges section where the first index in each row refers to the knot vector id (from the following knotvectors section), while the remaining two indexes are the edge vertex numbers. The position of the NURBS nodes (control points) is given as a NURBS grid function at the end of the file, while the associated weights are listed in the preceding weights section. Solutions from NURBS discretization spaces are also natively supported. For example here is the approximation for the solution of a simple Poisson problem on a refined version of the above mesh. glvis -m square-disc-nurbs.mesh -g sol.gf","title":"Details"},{"location":"options-and-use/","text":"Options and Use Quick start Start a socket server: glvis View a mesh: glvis -m star.mesh View a mesh with a finite element grid function: glvis -m star.mesh -g sol.gf View mesh and solution from a run on 4 processors: glvis -np 4 -m mesh -g sol (assuming data saved in files: mesh.000000 , ... , mesh.000003 and sol.000000 , ... , sol.000003 ) Use glvis -h to get help on all command line options. See README.md for a detailed description of the keystroke commands accepted in the GLVis interactive window. Some of the command-line options of GLVis and its general use are described in more details below: The GLVis server mode How to visualize meshes How to visualize functions GLVis scripts Options GLVis has a number of command-line options that allow it to be used in several different ways. The list of all available options is given by the output of glvis -h : _/_/_/ _/ _/ _/ _/ _/ _/ _/ _/ _/_/_/ _/ _/_/ _/ _/ _/ _/ _/_/ _/ _/ _/ _/ _/ _/ _/_/ _/_/_/ _/_/_/_/ _/ _/ _/_/_/ Start a GLVis server: glvis Visualize a mesh: glvis -m <mesh_file> Visualize mesh and solution (grid function): glvis -m <mesh_file> -g <grid_function_file> [-gc <component>] Visualize parallel mesh and solution (grid function): glvis -np <#proc> -m <mesh_prefix> [-g <grid_function_prefix>] All Options: -h, --help Print this help message and exit. -m <string>, --mesh <string>, current value: (none) Mesh file to visualize. -g <string>, --grid-function <string>, current value: (none) Solution (GridFunction) file to visualize. -gc <int>, --grid-function-component <int>, current value: -1 Select a grid function component, [0-<num-comp>) or -1 for all. -s <string>, --scalar-solution <string>, current value: (none) Scalar solution (vertex values) file to visualize. -v <string>, --vector-solution <string>, current value: (none) Vector solution (vertex values) file to visualize. -np <int>, --num-proc <int>, current value: 0 Load mesh/solution from multiple processors. -d <int>, --pad-digits <int>, current value: 6 Number of digits used for processor ranks in file names. -run <string>, --run-script <string>, current value: (none) Run a GLVis script file. -k <string>, --keys <string>, current value: (none) Execute key shortcut commands in the GLVis window. -fo, --fix-orientations, -no-fo, --dont-fix-orientations, current option: --dont-fix-orientations Attempt to fix the orientations of inverted elements. -a, --real-attributes, -ap, --processor-attributes, current option: --processor-attributes When opening a parallel mesh, use the real mesh attributes or replace them with the processor rank. -grt <int>, --geometry-refiner-type <int>, current value: 3 Set of points to use when refining geometry: 3 = uniform, 1 = Gauss-Lobatto, (see mfem::Quadrature1D). -sc, --save-coloring, -no-sc, --dont-save-coloring, current option: --dont-save-coloring Save the mesh coloring generated when opening only a mesh. -p <int>, --listen-port <int>, current value: 19916 Specify the port number on which to accept connections. -sec, --secure-sockets, -no-sec, --standard-sockets, current option: --standard-sockets Enable or disable GnuTLS secure sockets. -save, --save-stream, -no-save, --dont-save-stream, current option: --dont-save-stream In server mode, save incoming data to a file before visualization. -saved <string>, --saved-stream <string>, current value: (none) Load a GLVis stream saved to a file. -ww <int>, --window-width <int>, current value: 400 Set the window width. -wh <int>, --window-height <int>, current value: 350 Set the window height. -wt <string>, --window-title <string>, current value: (default) Set the window title. -c <string>, --plot-caption <string>, current value: (none) Set the plot caption (visible when colorbar is visible). -fn <string>, --font <string>, current value: (default) Set the font: [<font-name>[:style=<style>]][-<font-size>], e.g. -fn \"Helvetica:style=Bold-16\". -ms <int>, --multisample <int>, current value: 4 Set the multisampling mode (toggled with the 'A' key). -lw <double>, --line-width <double>, current value: 1 Set the line width (multisampling off). -mslw <double>, --multisample-line-width <double>, current value: 1 Set the line width (multisampling on). -oldgl, --legacy-gl, -anygl, --any-gl, current option: --any-gl Only try to create a legacy OpenGL (< 2.1) context. Server mode GLVis can be used as a visualization server, where it waits for data sent by socket connections from applications and visualizes each socket stream in a separate interactive window: To establish the GLVis server, open a new terminal and start the GLVis application without any options: glvis By default, the server is established on port 19916 , but this can be changed with the -p option. To save the incoming data, the server needs to be started with glvis -save With the -save option, all socket streams will be saved in incrementally named files glvis-saved.0001 , glvis-saved.0002 , and so on. These socket files consist of a data type identifier followed by a mesh and a finite element function. For example: fem2d_gf_data MFEM mesh v1.0 dimension 2 elements 1 1 3 0 1 2 3 boundary 4 1 1 1 0 1 1 2 1 1 1 3 2 1 1 0 3 vertices 4 nodes FiniteElementSpace FiniteElementCollection: Quadratic VDim: 2 Ordering: 0 0 1 1 0.1 0.5 0.9 0.5 0 0.45 0 0 1 0.9 -0.05 0.5 1 0.5 0.55 FiniteElementSpace FiniteElementCollection: Quadratic VDim: 1 Ordering: 0 0 0 0 0 0 0 0 0 1 Note that the mesh portion of the above file is the MFEM mesh v1.0 version of the quad.vtk mesh from the curvilinear VTK tutorial . The *.saved files contain an exact copy of the socket data stream which can be visualized later as follows: glvis -saved glvis-saved.0001 Below is the result for the above socket data using the following GLVis keystrokes in the OpenGL window: AmttOO followed by multiple refinements with o and move/zoom adjustments with the mouse. Visualizing meshes GLVis can also be employed in non-sever mode, e.g. to visualize a mesh file: glvis -m quad.vtk The optional -k parameter specifies a set of keystrokes, which will be passed directly to the GLVis window, see, e.g., the examples in the mesh formats tutorial . Two dimensional meshes are shown with elements in multiple colors, corresponding to a piece-wise constant function with different values in neighboring elements. This function can be generated and saved with the -sc option, which writes it in a file called GLVis_coloring.gf . Visualizing functions There are several ways to visualize a function on a given mesh. For example we can visualize the coloring function for the mesh beam-hex.mesh as follows: glvis -m beam-hex.mesh -sc glvis -m beam-hex.mesh -g GLVis_coloring.gf The result is: As another example, consider the finite element grid function quad.gf embedded in the socket stream glvis-saved.0001 discussed above: FiniteElementSpace FiniteElementCollection: Quadratic VDim: 1 Ordering: 0 0 0 0 0 0 0 0 0 1 Then glvis -m quad.vtk -g quad.gf will produce identical result to glvis -saved glvis-saved.0001 . Vector-valued grid functions are also supported. For example, consider the following data saved in a file named quad-vec.gf FiniteElementSpace FiniteElementCollection: Quadratic VDim: 2 Ordering: 0 0 0 0 -0.1 0 0.1 0 0 0.05 0 0 0 0.1 0.05 0 0 0 -0.05 which corresponds to the Q2 vector field transforming the quad.vtk quadrilateral into the unit square: The above plot was produced with: glvis -m quad.vtk -g quad-vec.gf -k \"RjlAmeOOooooooooooobbvuuuuuuuuuuu************\" The transformation between the two domains can be further explored with the b and n keys. One can also visualize the different components of a vector field as scalar functions using the -gc option, e.g. glvis -m quad.vtk -g quad-vec.gf -gc 1 gives after some manipulations the following plot: Finally, GLVis supports the visualization of functions with values provided only in the vertices of the mesh. This is only supported for non-curved meshes! The scalar and vector case are handled by the -s and -v options respectively. Here is an example with the beam-quad.mesh mesh file and a solution saved in a file beam-quad.sol : solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 glvis -m beam-quad.mesh -s beam-quad.sol -k \"Amaa\" Note that the data in this type of solution files starts from the second line (the first line contains an identifier). The vector format for the -v option is similar, with all the x-components of the field listed first, followed by all the y-components, etc. GLVis scripts GLVis can also run a batch sequence of commands, called GLVis scripts, which are useful for saving particular visualization scenes, as well as to generate still frames for animations. Scripts are executed with glvis -run . For example, consider the following script, saved in a file quad-vec.glvs : # Visualization window geometry window 0 0 300 300 # Initial solution solution quad.vtk quad-vec.gf # Setup the GLVis scene. Executed after pressing the space bar. { perspective off view 0 0 viewcenter 0 0 zoom 1.95 keys AmeOOooooooooooobbvuuuuuuuuuuu } # Take multiple screenshots. Executed after pressing the space bar. { keys b solution quad.vtk quad-vec.gf screenshot quad-vec.00.png keys b solution quad.vtk quad-vec.gf screenshot quad-vec.01.png keys b solution quad.vtk quad-vec.gf screenshot quad-vec.02.png keys b solution quad.vtk quad-vec.gf screenshot quad-vec.03.png keys b solution quad.vtk quad-vec.gf screenshot quad-vec.04.png keys b solution quad.vtk quad-vec.gf screenshot quad-vec.05.png keys b solution quad.vtk quad-vec.gf screenshot quad-vec.06.png keys b solution quad.vtk quad-vec.gf screenshot quad-vec.07.png keys b solution quad.vtk quad-vec.gf screenshot quad-vec.08.png keys b solution quad.vtk quad-vec.gf screenshot quad-vec.09.png keys b solution quad.vtk quad-vec.gf screenshot quad-vec.10.png } The # lines above indicate comments, while the braces separate the different sequences of commands that are executed together. GLVis will pause between these execution blocks, waiting for the user to press the space bar in order to continue. The solution command above updates the mesh and the finite element function plotted, without changing any other visualization parameters, while screenshot uses libpng (or LibTIFF , or xwd depending on the build configuration) with ImageMagick's convert utility to save a picture in the specified format. There are a number of additional script commands available, the complete list of which can be found (and extended) by examining the glvis.cpp source code . Executing glvis -run quad-vec.glvs and pressing the space bar twice in the GLVis window generates a sequence of screenshots, which can be animated, e.g., with convert -delay 20 quad-vec.??.png quad-vec.gif The generated animated GIF file is shown below (you may need to reload the page to see the animation): More examples of animations produced with GLVis scripts can be found at the BLAST website , e.g., here and here .","title":"Options and Use"},{"location":"options-and-use/#options-and-use","text":"","title":"Options and Use"},{"location":"options-and-use/#quick-start","text":"Start a socket server: glvis View a mesh: glvis -m star.mesh View a mesh with a finite element grid function: glvis -m star.mesh -g sol.gf View mesh and solution from a run on 4 processors: glvis -np 4 -m mesh -g sol (assuming data saved in files: mesh.000000 , ... , mesh.000003 and sol.000000 , ... , sol.000003 ) Use glvis -h to get help on all command line options. See README.md for a detailed description of the keystroke commands accepted in the GLVis interactive window. Some of the command-line options of GLVis and its general use are described in more details below: The GLVis server mode How to visualize meshes How to visualize functions GLVis scripts","title":"Quick start"},{"location":"options-and-use/#options","text":"GLVis has a number of command-line options that allow it to be used in several different ways. The list of all available options is given by the output of glvis -h : _/_/_/ _/ _/ _/ _/ _/ _/ _/ _/ _/_/_/ _/ _/_/ _/ _/ _/ _/ _/_/ _/ _/ _/ _/ _/ _/ _/_/ _/_/_/ _/_/_/_/ _/ _/ _/_/_/ Start a GLVis server: glvis Visualize a mesh: glvis -m <mesh_file> Visualize mesh and solution (grid function): glvis -m <mesh_file> -g <grid_function_file> [-gc <component>] Visualize parallel mesh and solution (grid function): glvis -np <#proc> -m <mesh_prefix> [-g <grid_function_prefix>] All Options: -h, --help Print this help message and exit. -m <string>, --mesh <string>, current value: (none) Mesh file to visualize. -g <string>, --grid-function <string>, current value: (none) Solution (GridFunction) file to visualize. -gc <int>, --grid-function-component <int>, current value: -1 Select a grid function component, [0-<num-comp>) or -1 for all. -s <string>, --scalar-solution <string>, current value: (none) Scalar solution (vertex values) file to visualize. -v <string>, --vector-solution <string>, current value: (none) Vector solution (vertex values) file to visualize. -np <int>, --num-proc <int>, current value: 0 Load mesh/solution from multiple processors. -d <int>, --pad-digits <int>, current value: 6 Number of digits used for processor ranks in file names. -run <string>, --run-script <string>, current value: (none) Run a GLVis script file. -k <string>, --keys <string>, current value: (none) Execute key shortcut commands in the GLVis window. -fo, --fix-orientations, -no-fo, --dont-fix-orientations, current option: --dont-fix-orientations Attempt to fix the orientations of inverted elements. -a, --real-attributes, -ap, --processor-attributes, current option: --processor-attributes When opening a parallel mesh, use the real mesh attributes or replace them with the processor rank. -grt <int>, --geometry-refiner-type <int>, current value: 3 Set of points to use when refining geometry: 3 = uniform, 1 = Gauss-Lobatto, (see mfem::Quadrature1D). -sc, --save-coloring, -no-sc, --dont-save-coloring, current option: --dont-save-coloring Save the mesh coloring generated when opening only a mesh. -p <int>, --listen-port <int>, current value: 19916 Specify the port number on which to accept connections. -sec, --secure-sockets, -no-sec, --standard-sockets, current option: --standard-sockets Enable or disable GnuTLS secure sockets. -save, --save-stream, -no-save, --dont-save-stream, current option: --dont-save-stream In server mode, save incoming data to a file before visualization. -saved <string>, --saved-stream <string>, current value: (none) Load a GLVis stream saved to a file. -ww <int>, --window-width <int>, current value: 400 Set the window width. -wh <int>, --window-height <int>, current value: 350 Set the window height. -wt <string>, --window-title <string>, current value: (default) Set the window title. -c <string>, --plot-caption <string>, current value: (none) Set the plot caption (visible when colorbar is visible). -fn <string>, --font <string>, current value: (default) Set the font: [<font-name>[:style=<style>]][-<font-size>], e.g. -fn \"Helvetica:style=Bold-16\". -ms <int>, --multisample <int>, current value: 4 Set the multisampling mode (toggled with the 'A' key). -lw <double>, --line-width <double>, current value: 1 Set the line width (multisampling off). -mslw <double>, --multisample-line-width <double>, current value: 1 Set the line width (multisampling on). -oldgl, --legacy-gl, -anygl, --any-gl, current option: --any-gl Only try to create a legacy OpenGL (< 2.1) context.","title":"Options"},{"location":"options-and-use/#server-mode","text":"GLVis can be used as a visualization server, where it waits for data sent by socket connections from applications and visualizes each socket stream in a separate interactive window: To establish the GLVis server, open a new terminal and start the GLVis application without any options: glvis By default, the server is established on port 19916 , but this can be changed with the -p option. To save the incoming data, the server needs to be started with glvis -save With the -save option, all socket streams will be saved in incrementally named files glvis-saved.0001 , glvis-saved.0002 , and so on. These socket files consist of a data type identifier followed by a mesh and a finite element function. For example: fem2d_gf_data MFEM mesh v1.0 dimension 2 elements 1 1 3 0 1 2 3 boundary 4 1 1 1 0 1 1 2 1 1 1 3 2 1 1 0 3 vertices 4 nodes FiniteElementSpace FiniteElementCollection: Quadratic VDim: 2 Ordering: 0 0 1 1 0.1 0.5 0.9 0.5 0 0.45 0 0 1 0.9 -0.05 0.5 1 0.5 0.55 FiniteElementSpace FiniteElementCollection: Quadratic VDim: 1 Ordering: 0 0 0 0 0 0 0 0 0 1 Note that the mesh portion of the above file is the MFEM mesh v1.0 version of the quad.vtk mesh from the curvilinear VTK tutorial . The *.saved files contain an exact copy of the socket data stream which can be visualized later as follows: glvis -saved glvis-saved.0001 Below is the result for the above socket data using the following GLVis keystrokes in the OpenGL window: AmttOO followed by multiple refinements with o and move/zoom adjustments with the mouse.","title":"Server mode"},{"location":"options-and-use/#visualizing-meshes","text":"GLVis can also be employed in non-sever mode, e.g. to visualize a mesh file: glvis -m quad.vtk The optional -k parameter specifies a set of keystrokes, which will be passed directly to the GLVis window, see, e.g., the examples in the mesh formats tutorial . Two dimensional meshes are shown with elements in multiple colors, corresponding to a piece-wise constant function with different values in neighboring elements. This function can be generated and saved with the -sc option, which writes it in a file called GLVis_coloring.gf .","title":"Visualizing meshes"},{"location":"options-and-use/#visualizing-functions","text":"There are several ways to visualize a function on a given mesh. For example we can visualize the coloring function for the mesh beam-hex.mesh as follows: glvis -m beam-hex.mesh -sc glvis -m beam-hex.mesh -g GLVis_coloring.gf The result is: As another example, consider the finite element grid function quad.gf embedded in the socket stream glvis-saved.0001 discussed above: FiniteElementSpace FiniteElementCollection: Quadratic VDim: 1 Ordering: 0 0 0 0 0 0 0 0 0 1 Then glvis -m quad.vtk -g quad.gf will produce identical result to glvis -saved glvis-saved.0001 . Vector-valued grid functions are also supported. For example, consider the following data saved in a file named quad-vec.gf FiniteElementSpace FiniteElementCollection: Quadratic VDim: 2 Ordering: 0 0 0 0 -0.1 0 0.1 0 0 0.05 0 0 0 0.1 0.05 0 0 0 -0.05 which corresponds to the Q2 vector field transforming the quad.vtk quadrilateral into the unit square: The above plot was produced with: glvis -m quad.vtk -g quad-vec.gf -k \"RjlAmeOOooooooooooobbvuuuuuuuuuuu************\" The transformation between the two domains can be further explored with the b and n keys. One can also visualize the different components of a vector field as scalar functions using the -gc option, e.g. glvis -m quad.vtk -g quad-vec.gf -gc 1 gives after some manipulations the following plot: Finally, GLVis supports the visualization of functions with values provided only in the vertices of the mesh. This is only supported for non-curved meshes! The scalar and vector case are handled by the -s and -v options respectively. Here is an example with the beam-quad.mesh mesh file and a solution saved in a file beam-quad.sol : solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 glvis -m beam-quad.mesh -s beam-quad.sol -k \"Amaa\" Note that the data in this type of solution files starts from the second line (the first line contains an identifier). The vector format for the -v option is similar, with all the x-components of the field listed first, followed by all the y-components, etc.","title":"Visualizing functions"},{"location":"options-and-use/#glvis-scripts","text":"GLVis can also run a batch sequence of commands, called GLVis scripts, which are useful for saving particular visualization scenes, as well as to generate still frames for animations. Scripts are executed with glvis -run . For example, consider the following script, saved in a file quad-vec.glvs : # Visualization window geometry window 0 0 300 300 # Initial solution solution quad.vtk quad-vec.gf # Setup the GLVis scene. Executed after pressing the space bar. { perspective off view 0 0 viewcenter 0 0 zoom 1.95 keys AmeOOooooooooooobbvuuuuuuuuuuu } # Take multiple screenshots. Executed after pressing the space bar. { keys b solution quad.vtk quad-vec.gf screenshot quad-vec.00.png keys b solution quad.vtk quad-vec.gf screenshot quad-vec.01.png keys b solution quad.vtk quad-vec.gf screenshot quad-vec.02.png keys b solution quad.vtk quad-vec.gf screenshot quad-vec.03.png keys b solution quad.vtk quad-vec.gf screenshot quad-vec.04.png keys b solution quad.vtk quad-vec.gf screenshot quad-vec.05.png keys b solution quad.vtk quad-vec.gf screenshot quad-vec.06.png keys b solution quad.vtk quad-vec.gf screenshot quad-vec.07.png keys b solution quad.vtk quad-vec.gf screenshot quad-vec.08.png keys b solution quad.vtk quad-vec.gf screenshot quad-vec.09.png keys b solution quad.vtk quad-vec.gf screenshot quad-vec.10.png } The # lines above indicate comments, while the braces separate the different sequences of commands that are executed together. GLVis will pause between these execution blocks, waiting for the user to press the space bar in order to continue. The solution command above updates the mesh and the finite element function plotted, without changing any other visualization parameters, while screenshot uses libpng (or LibTIFF , or xwd depending on the build configuration) with ImageMagick's convert utility to save a picture in the specified format. There are a number of additional script commands available, the complete list of which can be found (and extended) by examining the glvis.cpp source code . Executing glvis -run quad-vec.glvs and pressing the space bar twice in the GLVis window generates a sequence of screenshots, which can be animated, e.g., with convert -delay 20 quad-vec.??.png quad-vec.gif The generated animated GIF file is shown below (you may need to reload the page to see the animation): More examples of animations produced with GLVis scripts can be found at the BLAST website , e.g., here and here .","title":"GLVis scripts"},{"location":"parallel-visualization/","text":"Parallel Visualization Summary Description of the parallel visualization capabilities of GLVis. Details GLVis supports visualization of parallel meshes and grid functions, which are either saved in separate files or send through separate socket connections from each processor. In both cases, GLVis will stitch the parallel results to show the global mesh and solution, but the subdomain data can still be examined through the F3 / F4 , F8 , F9 / F10 and F11 / F12 keystrokes. For data saved in separate files, e.g. mesh.000000 , ... , mesh.000003 and sol.000000 , ... , sol.000003 from a run on 4 processors, the format is: glvis -np 4 -m mesh -g sol In other words, the actual mesh and solution file names are obtained from the above prefixes \" mesh \" and \" sol \" by appending \" . \" followed by a 6-digit processor/subdomain number padded with 0's, see e.g. this example . (Note that the related obsolete option -par3d was removed in version 2.0). For results send by separate socket connections from each processor, the parallel format just adds a prefix specifying the total number of processors and the current processor id: parallel <num_proc> <myid> An example of this can be found here . To illustrate the parallel visualization capabilities of GLVis, suppose that we have solves a simple Poisson problem on a 2x2 square grid using 2 processors. The processor mesh files generated, e.g. by MFEM's Parallel Example 1 , are \" mesh.000000 \": MFEM mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # POINT = 0 # SEGMENT = 1 # TRIANGLE = 2 # SQUARE = 3 # TETRAHEDRON = 4 # CUBE = 5 # dimension 2 elements 2 1 3 5 2 0 3 1 3 4 5 3 1 boundary 6 1 1 0 3 1 1 1 4 1 1 2 0 1 1 3 1 2 1 5 4 2 1 2 5 vertices 6 2 1 1 0 1 1 0.5 0.5 1 0 0.5 0.5 0.5 and \" mesh.000001 \": MFEM mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # POINT = 0 # SEGMENT = 1 # TRIANGLE = 2 # SQUARE = 3 # TETRAHEDRON = 4 # CUBE = 5 # dimension 2 elements 2 1 3 0 2 5 4 1 3 2 1 3 5 boundary 6 1 1 0 2 1 1 1 3 1 1 2 1 1 1 4 0 3 1 5 4 3 1 3 5 vertices 6 2 0 0 1 0 0.5 0 1 0.5 0 0.5 0.5 0.5 The corresponding linear (Q1) finite element solutions on each processor are, \" sol.000000 \": FiniteElementSpace FiniteElementCollection: Linear VDim: 1 Ordering: 0 0 0 0 0 0 0.09375 and \" sol.000001 \", which happens to be identical to \" sol.000000 \" in this case. As before, we can view the local mesh and solution on each processor by specifying its mesh and solution files: glvis -m mesh.000000 -g sol.000000 However, we can also view the global (stitched) mesh by specifying the number of processors, and the mesh prefix glvis -np 2 -m mesh The global parallel mesh and solution can be visualized with glvis -np 2 -m mesh -g sol and now we can use, e.g. the F11 / F12 keystrokes to shrink/zoom the subdomains corresponding to different processors. Here is what the result looks like for a refined version of this problem on 16 processors: Parallel meshes and solutions are also supported in GLVis scripts. The corresponding command is psolution <num_proc> <mesh_prefix> <attr_flag> <solution_prefix> where \" <attr_flag> \" controls if the boundary attributes should be replaced with the processor number or if they should be kept unchanged. This option is also available from the command line as \"'-a'\".","title":"Parallel Visualization"},{"location":"parallel-visualization/#parallel-visualization","text":"","title":"Parallel Visualization"},{"location":"parallel-visualization/#summary","text":"Description of the parallel visualization capabilities of GLVis.","title":"Summary"},{"location":"parallel-visualization/#details","text":"GLVis supports visualization of parallel meshes and grid functions, which are either saved in separate files or send through separate socket connections from each processor. In both cases, GLVis will stitch the parallel results to show the global mesh and solution, but the subdomain data can still be examined through the F3 / F4 , F8 , F9 / F10 and F11 / F12 keystrokes. For data saved in separate files, e.g. mesh.000000 , ... , mesh.000003 and sol.000000 , ... , sol.000003 from a run on 4 processors, the format is: glvis -np 4 -m mesh -g sol In other words, the actual mesh and solution file names are obtained from the above prefixes \" mesh \" and \" sol \" by appending \" . \" followed by a 6-digit processor/subdomain number padded with 0's, see e.g. this example . (Note that the related obsolete option -par3d was removed in version 2.0). For results send by separate socket connections from each processor, the parallel format just adds a prefix specifying the total number of processors and the current processor id: parallel <num_proc> <myid> An example of this can be found here . To illustrate the parallel visualization capabilities of GLVis, suppose that we have solves a simple Poisson problem on a 2x2 square grid using 2 processors. The processor mesh files generated, e.g. by MFEM's Parallel Example 1 , are \" mesh.000000 \": MFEM mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # POINT = 0 # SEGMENT = 1 # TRIANGLE = 2 # SQUARE = 3 # TETRAHEDRON = 4 # CUBE = 5 # dimension 2 elements 2 1 3 5 2 0 3 1 3 4 5 3 1 boundary 6 1 1 0 3 1 1 1 4 1 1 2 0 1 1 3 1 2 1 5 4 2 1 2 5 vertices 6 2 1 1 0 1 1 0.5 0.5 1 0 0.5 0.5 0.5 and \" mesh.000001 \": MFEM mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # POINT = 0 # SEGMENT = 1 # TRIANGLE = 2 # SQUARE = 3 # TETRAHEDRON = 4 # CUBE = 5 # dimension 2 elements 2 1 3 0 2 5 4 1 3 2 1 3 5 boundary 6 1 1 0 2 1 1 1 3 1 1 2 1 1 1 4 0 3 1 5 4 3 1 3 5 vertices 6 2 0 0 1 0 0.5 0 1 0.5 0 0.5 0.5 0.5 The corresponding linear (Q1) finite element solutions on each processor are, \" sol.000000 \": FiniteElementSpace FiniteElementCollection: Linear VDim: 1 Ordering: 0 0 0 0 0 0 0.09375 and \" sol.000001 \", which happens to be identical to \" sol.000000 \" in this case. As before, we can view the local mesh and solution on each processor by specifying its mesh and solution files: glvis -m mesh.000000 -g sol.000000 However, we can also view the global (stitched) mesh by specifying the number of processors, and the mesh prefix glvis -np 2 -m mesh The global parallel mesh and solution can be visualized with glvis -np 2 -m mesh -g sol and now we can use, e.g. the F11 / F12 keystrokes to shrink/zoom the subdomains corresponding to different processors. Here is what the result looks like for a refined version of this problem on 16 processors: Parallel meshes and solutions are also supported in GLVis scripts. The corresponding command is psolution <num_proc> <mesh_prefix> <attr_flag> <solution_prefix> where \" <attr_flag> \" controls if the boundary attributes should be replaced with the processor number or if they should be kept unchanged. This option is also available from the command line as \"'-a'\".","title":"Details"}]}